# 항목 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자 - 작성자: 고형주

<aside>
🔎

# 이것만은 잊지말자!

- 데이터 멤버는 private  멤버로 선언합시다. 이를 통해 클래스 제작자는 문법적으로 일관성 있는 데이터 접근 통로를 제공할 수 있고, 필요에 따라서는 세밀한 접근 제어도 가능하며, 클래스의 불변 속성을 강화할 수 있을 뿐만 아니라, 내부 구현의 융통성도 발휘할 수 있습니다.
- protected는 public보다 더 많이 ‘보호’받고 있는 것이 절대로 아닙니다.
</aside>

## 핵심 용어

<aside>

### **캡슐화 (Encapsulation)**

- **의미**: 데이터와 그 데이터를 조작하는 함수를 하나로 묶고, 외부로부터 데이터를 숨기는 것
- **목적**: 내부 구현을 바꿀 수 있는 자유를 보장
- **효과**: 코드 변경 시 영향 범위를 최소화

### **불변속성 (Invariant)**

- **의미**: 클래스 객체가 항상 유지해야 하는 조건이나 상태
- **중요성**: 객체의 일관성과 정확성 보장
- **구현**: private 멤버와 함수를 통한 제어로 달성

### **접근 제어 (Access Control)**

- **의미**: 클래스 멤버에 대한 접근 권한을 세밀하게 제어하는 것
- **종류**: 접근 불가, 읽기 전용, 쓰기 전용, 읽기/쓰기
- **장점**: 보안성과 안전성 향상
</aside>

 

---

<aside>

# 📌 왜 데이터 멤버가 public이면 안되는가?

</aside>

## **문법적 일관성과 세밀한 제어**

데이터 멤버가 `public`이 아니라면, 사용자 쪽에서 어떤 객체를 접근할 수 있는 유일한 수단은 멤버 함수가 된다. 그러므로 어떤 클래스의 공개 인터페이스에 있는 것들이 전부 함수 뿐이라면, 어떻게 접근해야 할지 고민할 필요 없이 함수를 쓰면 된다.

또한 함수를 사용하면 데이터 멤버의 접근성에 대해 정교한 제어를 할 수 있다. 어떤 데이터 멤버를 `public`으로 했다면 모두가 해당 멤버에 대해 읽기 및 쓰기 접근 권한을 갖게 된다. 그러나 이 값을 읽고 쓰는 함수가 있다면 접근 불가, 읽기 전용, 쓰기 전용, 읽기 쓰기 접근을 개발자가 직접 구현할 수 있다. 

```cpp
class AccessLevels {

	// 문법적 일관성: 모든 접근이 함수를 통해 이루어짐
	public:
	
		...
		
		int getReadOnly() const { return readOnly; }
		
		void setReadWrite(int value) { readWrite = value; }
		
		int getReadWrite() const { return readWrite; }
		
		void setWriteOnly(int value) { writeOnly = value; }
	
	// 세밀한 접근 제어
	private:
	
		int noAccess;  // 이 int에 대해서는 접근 불가
		
		int readOnly;  // 이 int에 대해서는 읽기 전용 접근
		
		int readWrite;  // 이 int에 대해서는 읽기 쓰기 접근
		
		int writeOnly;  // 이 int에 대해서는 쓰기 전용 접근
		
};

// 사용 예시
// 항상 함수를 호출하기 때문에 문법적으로 일관성 있음
AccessLevels obj;
obj.setReadWrite(10);       
int value = obj.getReadWrite();
```

세밀한 접근 제어는 보안 상 중요하다. 외부에 노출시키면 안되는 데이터 멤버가 존재하기 때문이다. 모든 데이터 멤버에 읽기 및 쓰기 함수를 만들어줄 일은 드물기도 하다. 

---

<aside>

# 📌 **캡슐화를 이용한 구현 변경의 자유**

</aside>

함수를 통해서만 데이터 멤버에 접근할 수 있도록 구현해두면, 데이터 멤버를 나중에 계산식으로 대체할 수도 있다. 그리고 사용자가 해당 클래스에 임의로 접근할 수 없게 한다. 

예) 자동화 장치를 이용하여 자동차가 지나가는 속도를 모니터링하는 프로그램

이 프로그램이 실행되면 자동차가 지나갈 때 마다 속도를 계산한 후에 지금까지 수집한 속도 데이터 집합에 그 속도를 추가한다.

```cpp
class SpeedDataCollection {

	...
	
	public:
		void addValue(int speed);  // 새 데이터 값을 추가합니다.
		
		double averageSoFar() const;  // 평균 속도를 반환합니다.
		...
		
	private:
    // 내부 구현은 언제든 바뀔 수 있음
};
```

## averageSoFar 멤버 구현 방법

**방법 1: 지금까지 수집한 속도 데이터 전체의 평균값을 담는 어떤 데이터 멤버를 클래스 안에 넣어두는 방법**

```cpp
private:
    double currentAverage_;
    int totalCount_;
    double totalSum_;
```

<aside>

**장점:** `averageSoFar` 함수 호출 시 즉시 반환 (빠른 속도)

**단점:**  평균값 유지를 위한 추가 메모리 필요 (객체 크기 증가)

</aside>

- `averageSoFar` 함수는 호출될 때마다 그 데이터 멤버의 값을 반환한다.
- 평균 값을 유지하기 위한 공간(현재의 평균 값, 누적 총합, 데이터의 개수 등) 할당이 필요하므로, `SpeedDataColleciton` 객체 하나의 크기가 커진다.
- 평균 값을 반환하기만 하는 인라인 함수이므로 `averageSoFar`는 효율 면에서 좋아질 수 있다.

**방법 2: 호출될 때마다 평균값을 계산하는 방법**

```cpp
private:
    std::vector<int> allSpeeds_;
```

<aside>

**장점:** 메모리 사용량 최소화 (객체 크기 작음)

**단점:** 매번 전체 데이터를 훑어야 함 (느린 속도)

</aside>

- 수집한 데이터를 매번 훑어가는 코드가 포함된다.
- 함수 자체의 속도가 느려진다.
- `SpeedDataColleciton` 객체 하나의 크기가 1번 방법보다 작다.

## 상황마다 좋은 방법은 다르다.

**메모리가 부족한 환경**의 기기, **평균값이 자주 필요하지 않은 응용프로그램**

→ 방법 2

**평균값을 빈번하게 사용**하고, **속도가 중요**하며, **메모리에 여유**가 있는 환경

→ 방법 1

## 캡슐화의 핵심

**“평균값 접근에 멤버 함수를 통하게 한다”(평균값을 캡슐화)**

캡슐화를 통해 내부 구현을 자유롭게 바꿀 수 있고, 사용자는 변경된 파일에 대해 컴파일만 하면 되기 때문이다. 

---

<aside>

# 📌 캡슐화가 제공하는 추가 혜택

</aside>

데이터 멤버를 함수 인터페이스 뒤에 감추면 구현 상의 융통성을 전부 누릴 수 있다.

## 확장 가능한 기능들

- 데이터 멤버를 읽거나 쓸 때 다른 객체에 알림 메시지를 보낼 때
- 클래스의 불변속성 및 사전조건, 사후조건을 검증할 때
- 스레딩 환경에서 동기화를 걸 때

```cpp
class Data {
private:
    int value_;
    
public:
    void setValue(int v) {
    
        // 1. 사전조건/사후조건 검증
        if (v < 0) throw std::invalid_argument("음수는 허용되지 않습니다");
        
        // 2. 다른 객체에 알림 메시지
        notifyObservers(value_, v);
        
        // 3. 스레딩 환경에서 동기화
        std::lock_guard<std::mutex> lock(mutex_);
        
        // 4. 로깅
        logValueChange(value_, v);
        
        value_ = v;
        
        // 5. 클래스의 불변속성 검증
        assert(isValidState());
    }
};
```

## 캡슐화는 중요하다

사용자로부터 데이터 멤버를 숨기면(캡슐화하면) 클래스의 불변속성을 항상 유지하는데 소홀해질 수가 없다. 불변속성을 보여줄 수 있는 통로가 멤버 함수 밖에 없기 때문이다. 

캡슐화는 현재의 구현을 나중에 바꾸기로 결정할 수 있는 권한을 예약하게 해주기도 한다. 

## 캡슐화를 하지 않으면

C++에서 **public은 캡슐화가 되지 않았다는 의미**이며, 이는 결국 **바꿀 수 없다는 의미**가 된다. 캡슐화를 하지 않으면 클래스의 소스 코드를 갖고 있더라도 사용자 코드가 깨질 수 있게 때문에 public으로 되어 있는 부분에는 손대기가 힘들다.  그러므로 내부 구현 개선 기능의 혜택을 받을 수 있는 클래스들이 캡슐화가 가장 필요하다.

---

<aside>

# 📌 protected도 public과 마찬가지로 위험하다

</aside>

protected 데이터 멤버도 문법적 일관성과 세밀한 접근 제어 측면에서 public과 같은 중요성을 가지게 된다. 

## 캡슐화 정도의 공식

어떤 것이 바뀌면(데이터 멤버가 클래스에서 제거되면), 깨질 가능성을 가진 코드가 늘어날 때 캡슐화의 정도는 그에 반비례해서 작아진다.

$$
캡슐화 \ 정도 \ ∝ \ 1 \ / \ (변경 \ 시  \ 깨질 \ 수 \ 있는 \ 코드의 \ 양)
$$

## **접근 수준별 영향 범위**

```cpp
class BaseClass {
public:
    int publicData;     // 모든 사용자 코드가 의존 가능
protected:
    int protectedData;  // 모든 파생 클래스가 의존 가능  
private:
    int privateData;    // 오직 이 클래스만 의존
};
```

- **`public` 데이터 멤버 제거** → 이를 사용하는 **모든 사용자 코드** 망가짐
- **`protected` 데이터 멤버 제거** → 이를 사용하는 **모든 파생 클래스 코드** 망가짐
- **`private` 데이터 멤버 제거** → **해당 클래스 내부만** 영향

`public` 데이터 멤버나 `protected` 데이터 멤버를 제거하면 코드는 망가진다. 조금 가렸다고 해도, 데이터 멤버가 바뀌면 해당 멤버에 의존하는 코드들이 망가지는 것은 마찬가지이다. `public` 또는 `protected`로 선언하고 사용자가 그것을 사용하기 시작했으면 그 멤버를 바꾸기는 힘들어진다. 코드를 다시 쓰고 테스트를 다시 해야 하며, 문서 변경도 하고, 컴파일을 다시 해야 하기 때문이다. 그러므로 캡슐화의 관점에서 쓸모 있는 접근 수준은 `private`(캡슐화 제공)과 `private`이 아닌 나머지(캡슐화 없음) 뿐이다.

## ✅ 결론: 캡슐화의 관점에서 쓸모 있는 접근 수준

1. **`private`** → 캡슐화 제공 ⭕
2. **`private`이 아닌 나머지** (`public`, `protected`) → 캡슐화 없음 ❌

**`protected`는 `public`보다 더 많이 '보호'받고 있는 것이 절대로 아니다.**

---

<aside>

# 📌 결론

</aside>

### 데이터 멤버는 반드시 private으로 선언하자

## **private 데이터 멤버가 제공하는 이점**

1. **문법적 일관성** - 모든 접근이 함수를 통해 이루어짐
2. **세밀한 접근 제어** - 읽기 전용, 쓰기 전용 등 자유롭게 제어
3. **캡슐화** - 내부 구현을 자유롭게 변경 가능
4. **확장성** - 유효성 검사, 알림, 동기화 등 추가 기능 구현
5. **불변속성 보장** - 클래스의 일관된 상태 유지