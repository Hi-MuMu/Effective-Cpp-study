# 항목 18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자 - 작성자: 한지윤

<aside>
🔎

# 이것만은 잊지말자!

- 좋은 인터페이스는 제대로 쓰기에 쉬우며 엉터리로 쓰기에 어렵습니다.
인터페이스를 만들때는 이 특성을 지닐 수 있도록 고민하고 또 고민합시다.
- 인터페이스의 올바른 사용을 이끄는 방법으로는 인터페이스 사이의 일관성 잡아주기, 그리고 기본제공 타입과의 동작 호환성 유지하기가 있습니다.
- 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있습니다.
- `tr1::shared_ptr` 은 사용자 정의 삭제자를 지원합니다. 이 특징 때문에 `tr1::shared_ptr` 은 교차 DLL 문제를 막아 주며, 뮤텍스 등을 자동으로 잠금 해제하는 데 쓸 수 있습니다.
</aside>

---

# 📌 인터페이스란 무엇인가?

### 🟩 **정의**

- 객체지향 프로그래밍(OOP)에서 인터페이스는 어떤 기능을 제공할지에 대한 약속
- 즉, 구현은 빼고 외부에 보여줄 `함수 이름`, `입력` , `출력` 만 정의한 것
- 인터페이스를 통해 **이 객체는 이런 기능을 쓸 수 있다** 라는걸 보장해줍니다

사실 C++에서 interface 키워드는 없지만, (Java에는 있고 개념만 따온거라고 합니다.)
추상 클래스 + 순수 가상 함수로 인터페이스를 표현합니다.

### 🟩 **포함되는 것**

- 클래스의 `public` 멤버함수
- 함수의 매개변수의 반환 타입
- 상속 시 제공되는 `순수 가상 함수`
    - `예제넣어야함`
- 라이브러리에서 제공하는 API
- 개념정리
    - 매개변수 = 함수 입력 값
    - 반환 타입 = 함수 출력값
    - 추상 메서드 = 구현이 없는 함수 → 자식 클래스가 반드시 구현해야함
    - 인터페이스 = 상속받은 클래스에서 추상 메서드를 오버라이드해야만 사용 가능

즉… 인터페이스는 사용자가 보는 `겉모습` 에 해당합니다!

---

# 📌 인터페이스를 개발하려면…

이상적으로는 어떤 인터페이스를 사용했을 때 사용자가 원하는 대로 동작하지 않는다면 그 코드는 컴파일되지 않아야하며, 만일 그 코드가 컴파일 됐다면 사용자가 원하는대로 동작해야 할 것 입니다.

여러분이 인터페이스를 개발하게 된다면 **사용자가 저지를 만한 실수의 종류**를 머리에 넣어두고 있어야 합니다.

### 🟩 예제 코드

```cpp
class Date
{
public:
  Data(int month, int day, int year);
  ...
}
```

첫 인상이 그리 나쁘지 않은 인터페이스 입니다.
하지만, 여기서 **사용자가 쉽게 저지를 수 있는 오류**가 적어도 두개있습니다.

1. 매개 변수의 순서가 잘못될 여지가 있습니다.
    
    ```cpp
    // Date(month, day, year)
    Date d(30, 3, 1995); // “3, 30“이어야 하는데, “30, 3“을 넣었습니다.
    ```
    
2. 월과 일에 해당하는 숫자가 어이없는 숫자일 수 있습니다.
    
    ```cpp
    // Date(month, day, year)
    Date d(3, 40, 1995); // “3, 30“이어야 하는데, “3, 40“을 넣었습니다.
    ```
    

**새로운 타입**을 들여와 인터페이스를 강화하면 상당수의 사용자 실수를 막을 수 있습니다.
바로 `타입 시스템`을 만들어, 간단한 `랩퍼(wrapper) 타입`을 각각 만들고 이 타입을 Date 생성자 안에 둘 수 있습니다.

### 🟩 1. **인터페이스를 강화하기 위한 새로운 타입 정의**

```cpp
struct Day {
  explicit Day(int d) :
    val(d)  {}
  int val;
};
```

```cpp
struct Month {
  explicit Month(int m) :
    val(m)  {}
  int val;
};
```

```cpp
struct Year {
  explicit Year(int y) :
    val(y)  {}
  int val;
};
```

```cpp
class Date
{
public:
  Data(const Month& m, const Day& d, const Year& y);
  ...
}
Date (30, 3, 1995);                   // 에러! 타입이 틀렸습니다.
Date (Day(30), Month(3), Year(1995);  // 에러! 타입이 틀렸습니다.
Date (Month(30), Day(3), Year(1995);  // 성공
```

책에서는 이것을 온전한 클래스로 만들면 위의 단순한 구조체보다 낫다고 하지만.. 이 부분에서는 넘어가겠습니다. 궁금하신 분들은 항목 22를 참조해주세요.

위처럼 타입을 적절히 준비해 두기만해도 인터페이스 사용 에러를 막는데 도움이 됩니다

### 🟩 2. 타입 안정성을 신경써서 만든다면?

적절한 타입이 준비되어 있다면, **각 타입의 값에 제약**을 가하더라도 괜찮은 경우가 되겠지요??
→ 월(月)이 가질 수 있는 유효한 값은 12개뿐 → Month 타입은 이 사실을 제약으로 사용할 수 있음!

```cpp
class Month
{
public:
  static Month Jan() {  return Month(1);} // 유효한 Month 값을 반환하는 함수들
  ...                                     // 이들이 어째서 함수로 되어있으며
  static Month Dec() {  return Month(12);}// 객체가 되면 안되는지에 대한 이야기는
	...                                     // 아래를 보면 있습니다.
private:                    
  explicit Month(int m);                  // Month 값이 새로 생성되지 않도록
  ...                                     // 명시호출 생성자가 private 멤버입니다
};                                        // 월 표현을 위한 내부 데이터

Date d(Month::Jan(), Day(30), Year(1995));`
```

1. **왜 `Month::Jan` 을 객체가 아니라 함수로 만들었을까?**
    
    보통이라면 아래와 같이 사용하고 싶을 수 있습니다.
    
    ```cpp
    class Month {
    public:
        static const Month Jan; // 정적 객체: 프로그램 전체에 하나만 존재
        static const Month Feb;
        ...
    };
    
    const Month Month::Jan(1);
    const Month Month::Feb(2);
    ```
    
    이렇게 하면 `Month::Jan` 이라는 객체를 직접 사용할 수 있습니다.
    하지만 **문제점**이 존재합니다.
    
    - `Month::Jan` 같은 **정적 객체(static object)**는 프로그램 시작 시 초기화돼야 함
    - `항목4` 를 살펴보면…
        
        > 비지역 정적 객체 초기화 순서 **정의되지 않음** → 위험
        > 
        
        이라고 언급되어 있습니다!
        
    - C++에서는 비지역 정적 객체의 초기화 순서가 여러 번역 단위(.cpp파일) 간에 보장되지 않음
    → 즉, 다른 소스 파일에서 `Month::Jan`을 사용하려고 할 때 **아직 초기화되지 않았을 수 있음!**

1. **함수로 만든 경우의 장점**
    
    ```cpp
    static Month Jan() { return Month(1); }
    ```
    
    - 이건 객체가 아니고 `정적 함수`
    - 호출될 때마다 `Month(1)`이라는 **임시 객체$^*$**를 반환
        
        **$^*$** 임시객체: 잠깐 사용되었다가, 사용이 끝나면 바로 소멸되는 객체, 리터럴 값, 함수 반환 값
        
    - 따라서 **비지역 정적 객체 초기화 순서 문제**를 피해갈 수 있음!
    - C++표준에 따라 함수는 언제든지 안전하게 호출 가능하니까, **초기화 순서 문제에서 자유로워짐**

<aside>

💡 **enum 타입을 쓰면 안되나요?**

enum을 넣는 방법이 있긴한데 타입 안정성은 그리 믿음직하지 못하다고 합니다.

1. `enum` 방식의 한계

```cpp
enum Month { Jan=1, Feb, Mar, Apr, May, Jun, 
             Jul, Aug, Sep, Oct, Nov, Dec };

void printMonth(Month m) {
    // 코드...
}

printMonth(Jan);   // ✅ 정상
printMonth(13);    // ❌ 컴파일러가 막지 못함! (암묵적 변환 허용)
```

- `enum` 은 사실상 int와 호환돼서, `printMonth(13)`  같은 엉터리 값도 전달 가능
→ 이 부분이 **타입 안정성이 믿음직스럽지 못하다**는 이유
- 인터페이스가 엉터리로 쓰일 위험이 커짐

1. 클래스로 `Month`를 만든 경우
    
    ```cpp
    class Month
    {
    public:
      static Month Jan() {  return Month(1);} // 유효한 Month 값을 반환하는 함수들
      ...                                     // 이들이 어째서 함수로 되어있으며
      static Month Dec() {  return Month(12);}// 객체가 되면 안되는지에 대한 이야기는
    	...                                     // 아래를 보면 있습니다.
    private:                    
      explicit Month(int m);                  // Month 값이 새로 생성되지 않도록
      ...                                     // 명시호출 생성자가 private 멤버입니다
    };                                        // 월 표현을 위한 내부 데이터
    
    Date d(Month::Jan(), Day(30), Year(1995));
    ```
    
    - 이렇게 만들면 **허용된 값만 만들 수 있도록 제약** 가능
    - `int` 와 암묵 변환되지 않음 → 잘못된 값 전달이 불가능
    - `enum`보다 한 단계 더 나아가서, **강화된 타입(클래스로 캡슐화한 Month)**을 쓰면 진짜 안전해지는 것임
</aside>

### 🟩 3. 제약을 부여하자

예상되는 사용자 실수를 막는 다른 방법으로는 어떤 타입이 **제약을 부여하여 그 타입을 통해 할 수 있는 일들을 묶어 버리는 방법**이 있습니다.

아주 흔히 쓰이는 예는 `const` 붙이기 입니다. 이 부분은 `항목3` 을 참고하면 도움됩니다.

> **const와 함수**
> 
> 
> 함수 선언문에 있어서 const는 함수 반환 값, 각각의 매개변수, 멤버 함수 앞에 붙을 수 있고, 함수 전체에 대해 const의 성질을 붙일 수 있음.
> 
> 함수 반환 값을 상수로 정하면, **안전성이나 효율을 포기하지 않고도 사용자측의 에러 돌발 상황을 줄이는 효과**
> 
> ```cpp
> class Rational {...};
> const Rational operator*(const Rational& lhs, const Rational& rhs);
> ```
> 

`항목3`에 정리된 것 처럼 `operator*` 의 반환 타입을 `const`로 한정함으로써 사용자가 사용자 정의 타입에 대해 다음과 같은 실수를 저지르지 않도록 할 수 있습니다.

1. **const 붙이기 예시**
    
    ```cpp
    if (a * b = c) // 흑, 나는 원래 비교하려고 그랬던 건데!
    ```
    
    - 위 코드 같은 경우, 비교(`==`)하려던 건데 실수로 대입 (`=`)한 경우, 반환 타입이 `const` 라면 이런 잘못된 대입을 막을 수 있습니다
    - 만약, `operator*` 가 **비-const 객체를 반환**한다면 `a*b` 의 결과(임시 객체)에 대입이 가능해져 버림
    - 이 코드는 **컴파일 에러가 안나고, 논리 버그**로 이어짐
    
    이런 제약은 사용자가 잘못 쓸 수 있는 길을 일부러 막아주는 장치입니다.
    즉, **일반적인 올바른 사용은 편하게, 잘못된 사용은 아예 불가능하게 만드는게 목적**입니다.
    

1. **일반적인 지침**
    - 특별한 이유가 없다면, 사용자가 만든 타입도 **기본 제공 타입(int, double 등)처럼 동작**하게 하는게 원칙
    - 왜냐면 사람들이 이미 기본 타입의 동작을 잘 알고 있어서, 사용자 정의 타입도 그 기대를 깨면 혼란을 줌
    → 직관에서 어긋나지 않게 하자!

---

# 📌 일관성있는 인터페이스 제공

### **🟩 STL 컨테이너의 일관성**

STL 컨테이너의 인터페이스는 일반적으로 일관성을 가지고 있습니다.
한 예로, 모든 STL 컨테이너는 `size` 란 멤버 함수를 개방해 놓고 있습니다.

Java의 경우, 배열에 대해선 `lengh property`를 사용하고, String에 대해서는 `lenght method` 를 불러야하며 List에 대해서는 `size method`를 쓰도록 되어있습니다.

<aside>

🚨  사용자 쪽에서 뭔가를 외워야 제대로 쓸 수 있는 인터페이스는 잘못 쓰기 쉽습니다!

</aside>

### 🟩 팩토리 함수를 사용한 예제

<aside>

 💡 **팩토리 함수란?**

- 객체 생성을 대신해주는 함수
- `new` 나 `생성자 호출` 을 직접 하지 않고, **전용 함수**를 통해 객체를 만드는 방식

```cpp
class Investment {
public:
    virtual ~Investment() {}
    // ...
};

// 팩토리 함수
Investment* createInvestment() {
    // 어떤 상황에 따라 적절한 파생 클래스 객체를 만들어 반환
}

int main() {
    Investment* inv = createInvestment();
    // ... 사용 ...
    delete inv;  // 깜빡하면 메모리 누수 발생
}
```

- 사용자는 `new Stock()` 같은걸 직접 쓰지 않고, `createInvestment()` 같은 팩토리 함수를 통해 객체를 받음
- 즉, **생성 과정을 인터페이스로 감싸는 것**이 팩토리 패턴의 핵심
→ **인터페이스 단순화**
</aside>

하지만 위의 예제와 같이 사용하게 된다면 실수하기 쉽습니다.
포인터 삭제를 깜빡할 수 있고, 똑같은 포인터에 대해 `delete`가 두 번 이상 적용될 수 있음

**이에 대한 해결책은?**

- 팩토리 함수는 반환 타입을 `auto_ptr`, `shared_ptr` 같은 스마트 포인터로 강제하면
→ **자원 누수가 방지됨**
    
    ```cpp
    std::shared_ptr<Investment> createInvestment() {
    		// 내부 코드
    }
    ```
    
- 이렇게하면 항상 안전한 방식으로만 객체를 쓰도록 인터페이스가 제한됩니다.
- 해당 포인터의 삭제 작업을 스마트 포인터에게 떠넘기는 방법

# 📌 shared_ptr

- `tr1::shared_ptr` 아닌가요?
    
    <aside>
    
    **TR1(Technical Report 1)**
    
    - C++ 11 표준이 나오기 전에, 표준에 미리 추가될 라이브러리를 제안하고 모아둔 “임시 확장판”입니다.
    - C++ 03 시절에는 스마트 포인터가 표준에 없었습니다
    
    즉, `tr1::shared_ptr` ⇒ C++11 이전에 쓰던 스마트 포인터 구현
    
    최신 C++에서는 스마트 포인터가 정식 표준에 들어왔습니다.
    `tr1::` 을 사용하지 않아도 되고, 최신 컴파일러에서는 아예 지원이 안될수도 있습니다.
    
    </aside>
    

### **🟩 shared_ptr 예제**

- `createInvestment()`가 `Investment*`를 반환하면 사용자가 직접 `delete` 해야 함.
- 실수로 `delete`를 깜빡하거나, 잘못 호출하면 → **자원 누수 / 중복 해제** 발생.

⇒ 그래서 스마트 포인터(`shared_ptr`)를 반환하는 게 안전.

**1. 사용자 정의 삭제자(custom deleter)**

`항목14` 에서 나온것처럼 `shared_ptr` 은 생성 시점에 **삭제자를 직접 엮을 수 있는 기능**을 가지고 있습니다.

이러한 기능을 이용하여 `createInvestment` 를 통해 얻은 `Investment*` 포인터를 직접 삭제하지 않고, `getRidOfInvestment` 이름의 함수를 준비하여 여기에 넘기면 어떻게될까요?

보기에는 깔끔해보이지만, 실수하게 될 가능성이 더 커지게됩니다. 만들어둔 `getRidOfInvestment` 를 사용하지 않고 `delete` 를 써버릴 수도 있습니다.

1. `shared_ptr` **삭제자 사용**
    
    `shared_ptr` 에는 두 개의 인자를 받는 생성자가 있습니다.
    
    - 첫번째 인자 → 관리할 포인터
    - 두번째 인자 → 참조 카운트가 0이 될 때 호출되는 삭제자
    
    `shared_ptr` 이 `null` 포인터를 물게함과 동시에 삭제자`getRidOfInvestment` 를 갖게하는 방법은 어떨까요?
    
    ```cpp
    std::shared_ptr<Investment> pInv(0, getRidOfInvestment); // 컴파일이 안됩니다
    ```
    
    첫 번째 인자인 `0`은 포인터가 아니고 `int`입니다.
     `shared_ptr` 이 요구하는 포인터는 `Investment*` 타입의 실제 포인터를 요구합니다
    
    따라서 **캐스트**를 적용하여 해결합니다.
    
    ```cpp
    std::shared_ptr<Investment>
        pInv(static_cast<Investment*>(0), getRidOfInvestment);
    ```
    
    - **cast**
        
        `항목27`에 나오긴 함
        
        1. **캐스트란?**
            - **타입 변환(type conversion)**을 강제로 시키는 방법
            - 컴파일러가 자동으로 변환하지 않는 경우에도, 개발자가 “이 타입으로 취급해!”라고 지시하는 것
            - 즉, **강제 형변환**
        2. 캐스팅의 주의사항
            - 캐스트는 가능한 피하는게 좋고 꼭 필요할 때만 써야함
            - **타입 시스템을 무시**하기 때문에 → 안전성 ↓
            - **코드 가독성 저하** → 유지보수 어려움
            - 잘못 쓰면 **정의되지 않은 동작(UB)** 발생
            
        
        여기서는 생성자가 원하는 타입을 맞추기 위해 쓰는거라 괜찮다고함
        
    
    <aside>
    
    🚀 근데 C++11 이상에서는 `nullptr`이 있어서 캐스트를 굳이 쓸 필요 없다고 함
    
    </aside>
    

### 🟩 per-pointer 삭제자(Deleter)가 왜 좋은가?

`shared_ptr` 은 포인터마다 “삭제 방법”을 함께 저장할 수 있습니다.

```cpp
std::shared_ptr<Investment> p{ new Stock, getRidOfInvestment };
// 마지막 하나가 파괴될 때 getRidOfInvestment(ptr) 호출
```

- 이렇게 하면 사용자가 `delete` 를 깜빡할 위험이 없어짐 → 자동 해제
- 특수한 해제 절차(예: 로그 남기기)를 강제할 수 있음

### 🟩 cross-DLL 문제

서로 다른 DLL 사이에서 new/delete 짝이 엇갈리는 문제

- 객체를 **DLL A**에서 `new`로 만들고, **DLL B**에서 `delete`하면
    
    각 DLL이 **다른 런타임/힙**을 쓰는 환경에선 크래시가 나기 쉽습니다.
    
- `shared_ptr`은 **포인터마다 삭제자 함수를 저장**하므로,
    
    객체를 만든 쪽에서 지정한 “정확한 삭제자(그 DLL의 delete 또는 커스텀 deleter)”가
    
    **참조 카운트가 0이 되는 시점에 그대로 호출**됩니다.
    
- 즉, `shared_ptr` 인스턴스가 DLL 경계를 넘어 다녀도,
    
    **마지막 해제는 항상 올바른 삭제자**로 수행되어 cross-DLL 문제를 회피할 수 있습니다.
    

---

# **📌 Appendix**

- 항목 2 : '#define’을 쓰려거든 const, enum, inline을 떠올리자
- 항목 3 : 낌새만 보이면 const를 들이대자!
- 항목 4 : 객체를 사용하기 전에 반드시 그 객체를 초기화하자
- 항목 13 : 자원 관리에 객체가 그만!
- 항목 14 : 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자
- 항목 22 : 데이터 멤버가 선언될 곳은 private 영역임을 명심하자
- 항목 26 : 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자
- 항목 55 : 컴파일러 경고를 지나치지말자