# 항목 23: 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자 - 작성자: 서영은

<aside>
🔎

# 이것만은 잊지말자!

- 멤버 함수보다 비멤버 비프렌드 함수를 자주 쓰자.
- 캡슐화 정도가 높아지고, 패키징 유연성이 커지며, 기능적인 확장성도 늘어난다!
</aside>

---

# 📌 멤버 함수와 비멤버 비프렌드 함수

## 멤버 함수 버전

```cpp
class WebBrowser {
public:
	...
	void clearCache();
	void clearHistory();
	void removeCookies();
	void clearEverything(); // clearCache, clearHistory, removeCookies 호출
};
```

## 비멤버 비프렌드 함수 버전

```cpp
void clearBrowser(WebBrowser& wb)
{
	wb.clearCache();
	wb.clearHistory();
	wb.removeCookies();
}
```

- `friend` 란? 함수나 클래스 선언 앞에 사용할 수 있음. 접근 제어 지시자 (private, protected 등)의 영향을 받지 않음.
    
    ```cpp
    #include <iostream>
    
    class People
    {
    private:
    	std::string name;
    
    public:
    	People(std::string n) : name(n) {}
    	
    	friend void sayName(const People& p);
    };
    
    void sayName(const People& p)
    {
    	std::cout << "Name: " << p.name << std::endl;
    }
    
    int main()
    {
    	People p1("Alice");
    	sayName(p1);
    
    	return 0;
    }
    ```
    
    ![image.png](image.png)
    
    **friend 선언 없는 경우**
    
    ![image.png](image%201.png)
    
    ![image.png](image%202.png)
    
    **출처** https://coding-factory.tistory.com/698
    

# 📌 비멤버 비프렌드 함수가 더 좋은 이유

- 캡슐화 정도 높음
- 패키징 유연성(packaging flexibility) 높음
- 낮은 컴파일 의존도와 높은 클래스 확장성

## ✅ 캡슐화 정도가 높다

**객체 지향 4가지 특징**

- `추상화(Abstration)` : 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
- `상속성(Inheritance)` : 상위 클래스(부모 클래스)의 모든 속성과 기능을 하위 클래스가 물려받는 것
- `다형성(Polymorphism)` : 어떤 객체의 속성이나 기능이 맥락에 따라 다른 역할을 수행할 수 있는 것
(오버라이딩, 오버로딩)
- `캡슐화(Encapsulation)` : 서로 연관 있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것 (데이터 보호, 데이터 은닉)
- **참고**
    
     ****https://coding-factory.tistory.com/328
    
    https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95
    

어떤 것을 캡슐화하면, 외부에서 이것을 볼 수 없게 됨.

캡슐화하는 것이 늘어나면 그만큼 밖에서 볼 수 있는 것들은 줄어듦.

밖에서 볼 수 있는 것들이 줄어들면, 그것들을 바꿀 때 필요한 유연성이 커짐.

변경 자체가 영향을 줄 수 있는 범위가 `변경된 것을 볼 수 있는 것들`로 한정되기 때문.

이미 있는 코드를 바꾸더라도 제한된 사용자들밖에 영향을 주지 않는 융통성을 확보할 수 있음.

어떤 객체의 데이터를 직접 접근할 수 있는 코드가 적으면 적을수록 그 데이터는 많이 캡슐화 된것이고,

그 객체가 가진 데이터의 특징을 바꿀 수 있는 자유도가 그만큼 높은 것.

즉, **데이터를 접근하는 함수가 많으면 그 데이터의 캡슐화 정도는 낮다**는 의미.

private 멤버는 멤버 함수 및 프렌드 함수만 접근할 수 있으므로, 데이터에 접근할 수 있는 함수의 개수를 예측하기 쉬움.

멤버 함수는 클래스의 모든 것을 접근 가능.

비멤버 비프렌드 함수는 어떤 클래스의 private 부분은 접근 불가.

캡슐화 정도를 생각해봤을 때, **private 멤버에 접근할 수 없는 비멤버 비프렌드 함수가 더 바람직**.

### ⚠️ 주의해야 할 점 2가지

- **비멤버 비프렌드(non-friend) 함수에만 적용됨**
    - 프렌드 함수는 private 멤버에 대한 접근권한이 멤버 함수가 가진 접근권한과 동일함
    - ⇒ 캡슐화에 대한 영향이 멤버 함수와 같음.
- **다른 클래스의 멤버 함수로 만들어도 됨**
    - 위 코드를 예로들면 WeBroswer 클래스의 멤버나 프렌드가 아니기만 하면 됨.
    - 다른 유틸리티 클래스의 정적 멤버 함수로 만들어도 됨
    - 즉, private 멤버의 캡슐화에 영향을 주지 않으면 됨

## ✅ 패키징 유연성이 높고 컴파일 의존성이 낮고 확장성이 높다

**비멤버 함수를 클래스와 같은 네임스페이스 안에 두자**

```cpp
namespace WebBrowserStuff {
	class WebBrowser { ... };
	void clearBrowser(const WebBrowser& wb);
	...
}
```

네임스페이스는 클래스와 달리 여러 개의 소스 파일에 나뉘어 흩어질 수 있음

clearBrowser 같은 편의 함수는 멤버도 프렌드도 아니라서 사용자 수준에서 얻어낼 수 없는 기능은 제공할 수 없음

예를 들어 clearBrowser가 없어도 사용자는 그냥 clearCache, clearHistory, removeCookies 부르면 됨

응용도가 높은 클래스는 편의 함수가 많이 생길 수 있음

관련 편의 함수를 하나의 헤더 파일에 몰아서 선언하면, 사용자가 원하는 헤더만 가져다가 쓸 수 있음

```cpp
// "webbrowser.h" => WebBrowser 클래스 자체에 대한 헤더
// WebBroswer에 관련된 핵심 기능들이 선언되어 있음
namespace WebBroswerStuff {
	class WebBroswer { ... };
	...                       // 핵심 기능. 거의 모든 사용자가 써야하는 비멤버 함수들
}

// "webbrowserbookmarks.h"
namespace WebBrowserStuff {
	...                       // 즐겨찾기 관련 편의 함수들
}

// "webbrowsercookies.h"
namespace WebBrowserStuff {
	...                       // 쿠키 관련 편의 함수들
}
```

표준 C++ 라이브러리가 이러한 구조로 구성되어 있음.

std 네임스페이스에 속한 것들이 <vector>, <algorithm>, <list> 등에 흩어져 선언되어 있음.

이렇게 하면, **사용자가 실제로 사용하는 구성요소에 대해서만 컴파일 의존성을 고려**할 수 있음.

뿐만 아니라 편의 함수 집합의 **확장(extend)**도 쉬움.

네임스페이스에 비멤버 비프렌드 함수를 원하는 만큼 추가하면 됨.