<aside>

# 🔎이것만은 잊지말자!

- 지역 스택 객체에 대한 포인터나 참조자를 반환하는 일, 혹은 힙에 할당된 객체에 대한 참조자를 반환하는 일, 또는 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일은 그런 객체가 두 개 이상 필요해질 가능성이 있다면 절대로 하지 마세요!

</aside>

<br>

> 여러분이 선택한 결과를 최대한 저비용으로 만들려면 어떻게 해야 하는지 파악하느라 끙끙대는 일은 컴파일러 제작사에게 맡기라 이겁니다.
> 

### 요약

- 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 하지 마라
- 참조자를 쓰면 객체 생성과 소멸에 들어가는 비용이 없으니까 더 빠른거 아니야?
    - 그건 맞긴 해
- 근데 참조자는 “이미 존재하는 객체의 다른 이름” 이잖슴.
- 그럼 애초에 이미 존재하는 객체가 필요한데요??
    - 얘는 조상님이 생성해주냐?

[쓰레기 코드1] 스택 메모리

```cpp
const Rational& operator*(const Rational& lhs, const Rational& rhs){
	Rational result(lhs.n * rhs.n, lhs.d * rhs.d);
	return result;
}
```

- 봐바 함수 안에서 새로운 객체 생성하잖슴
- 어차피 비용은 동일함
- 그리고 이거 잘못됐음
- 함수 안에서 객체 생성했지 → 함수 스코프에서만 쓸 수 있어(함수에서 나오면 소멸됨) → 이거 호출 결과 쓰레기값임

[쓰레기 코드2] 힙 메모리

- ㅇㅋㅇㅋ heap에 할당하면 되잖슴ㅋ

```cpp
const Rational& operator*(const Rational& lhs, const Rational& rhs) {
	Rational *result = new Rational(lhs.n * rhs.n, lhs.d * rhs.d);
	return *result;
}
```

- 일단 어차피 생성자 호출해야하는거 보이시죠? ㅇㅇ 조상님은 없답니다
- 그리고 동적 할당하면 이거 메모리 누수는 누가 책임짐?
- 클래스에서 이렇게 만들어버리면 사용자는 메모리 누수 책임이 없음

[쓰레기 코드3]

- `static` 으로 정적 할당하면 되잖슴 → 장난침? 모든 객체가 동일할텐데?

[이렇게 하세요잉]

```cpp
inline const Rational operator*(const Rational& lhs, const Rational& rhs) {
	return Rational(lhs.n * rhs.n, lhs.d * rhs.d);
}
```