# 항목 20: ‘값에 의한 전달’보다는 ‘상수객체 참조자에 의한 전달1 방식을
택하는 편이 대개 낫다 - 작성자: 권우현

<aside>

# 💡이것만은 잊지말자!

- ‘값에 의한 전달’ 보다는 ‘상수 객체 참조자에 의한 전달’을 선호합시다. 대체적으로 효율적일 뿐만 아니라 복사 손실 문제까지 막아줍니다.
- 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 타입에는 맞지 않습니다. 이들에 대해서는 ‘값에 의한 전달’ 이 더 적절합니다.
</aside>

---

기본적으로 C++은 함수로부터 객체를 전달받거나 함수에 객체를 전달할 때 ,

‘**값에 의한 전달**(pass-by-value)’방식을 사용. (c에서 물려받은 특성 중 하나). 

함수 매개변수는 실제 인자의 ‘사본’을 통해 초기화 되며, 어떤 함수를 호출 한 쪽은 그 함수가 반환한 값의 ‘사본’을 돌려받습니다.

# 1. 복사생성자

- 이때 사본을 만들어 내는 원천
- 이 때문에 ‘값에 의한 전달’이 고비용의 연산이 되기도 함.

```cpp
class Person {
public:
    Person();              // 매개변수는 간결함을 위해 생략합니다.
    virtual ~Person();     // 가상 소멸자인 이유는 항목 7에서 확인하세요.
    ...
    
private:
    std::string name;
    std::string address;
};

class Student: public Person {
public:
    Student();             // 역시 비슷한 이유로 매개변수 생략
    ~Student();
    ...
    
private:
    std::string schoolName;
    std::string schoolAddress;
};

```

```cpp
bool validateStudent(Student s); // Student를 값으로 
																	// 전달받는 함수
																	
Student plato; //소크라테스의 제자 플라톤
bool platoIsOK = validateStudent(plato); //이제 함수를 호출합니다.
```

⇒ validateStudent는 Student 인자를 전달받고 (값으로) 이 인자가 유효화됐는가를 알려 주는 값을 반환함.

⇒ 그렇다면 validateStudent함수가 호출될 때 어떤 일이 일어날것인가?

- validateStudent(plato)
    - **함수의 매개변수 전달 비용** :  생성자 6번, 소멸자 6번
        - Student의 복사 생성자 호출
            - plato 로부터 매개변수 s 를 초기화 하기 위해 Student의 복사 생성자가 호출
            - Student 객체에는 String 객체 두 개가 멤버로 들어 있기 때문에, Student 객체가 생성될 때마다 덩달아 생성.
            - Student 객체는 Person객체로부터 파생되었기 때문에，Student 객체가 생성되면 Person 객체도 (먼저) 생성되어야 함.
            - Person 객체 안에는 또 String 객체 두 개가 들어 있기 때문에，Person
            객체가 매번 생성될 때 String 생성자가 두 번 더 호출.
            - 최종 결과:
                - Student: 객체 하나를 값으로 전달했을 뿐인데 Student 복사 생성자 호출
                한 번，Person 복사 생성자 호줄 한 번에 추가로 String 복사 생성자 호줄이 네 번 일
                어남.
        - Student의 소멸자 호출
            - 앞에서 호출된 생성자들 각각이 소멸자 호출과 대응.
            
        
        ***⇒ 총 생성자 6번, 소멸자 6번***
        
    
    **# 더 효율적인 코드는 없을까?**
    

# 2. 상수객체에 대한 참조자(reference-to-const)로 전달

## 1) 참조 전달의 형태

```cpp
bool validateStudent(const Student& s);
```

- 값에 의한 전달과 참조에 의한 전달의 차이는?
    
    ## 1. 값 전달 (pass-by-value)
    
    ```cpp
    void f(Student s);
    ```
    
    - 호출자가 `plato`를 넘기면, 함수 안에서 `s`라는 **새로운 Student 객체**가 복사돼 만들어져.
    - 즉, **원본과 별도**.
    - 메모리 그림으로 보면:
        
        ```
        plato ---> [Student 객체 A]
        s     ---> [Student 객체 B]  (복사본)
        ```
        
    - A와 B는 다른 객체. `s`를 바꿔도 `plato`는 영향 없음.
    
    ---
    
    ## 2. 참조 전달 (pass-by-reference)
    
    ```cpp
    void f(Student& s);
    ```
    
    - `plato`를 넘기면, 함수 안의 `s`는 **plato의 별칭(alias)**이 돼.
    - 별도의 객체를 만드는 게 아니라, **같은 객체를 가리킴**.
    - 구현 차원에서는 컴파일러가 내부적으로 **포인터(주소)**를 넘겨 처리해.
    - 메모리 그림:
        
        ```
        plato ---> [Student 객체 A]
        s ---------^   (같은 객체)
        ```
        
    - `s.schoolName = "abc";` 하면 `plato.schoolName`이 진짜로 바뀐다.
    
    ---
    
    ## 3. const 참조 전달
    
    ```cpp
    void f(const Student& s);
    ```
    
    - 위와 똑같이 **주소를 넘겨서 원본을 가리키지만**,
    - `s`를 통해 원본을 수정하는 건 금지됨.
    - 즉, 성능은 참조 전달만큼 좋고, 안정성은 값 전달만큼 안전.
- 새로 만들어지는 객체 같은 것이 없기 때문에, 생성자와 소멸자가 **호출되지 않음**.
- 주의해야 할 점.
    - 원래의 validateStudent는 Student 매개변수를 값으로 받아, 호출부에서 함수로 전달된 Student 객체에 어떤 변화가 생기더라도 그 변화로부터 안전하게 보호를 받음.
    - 사본이기 때문에!
    - 하지만 지금은 전달 방식이 참조에 의한 전달
        - 매개변수 앞에 **const**를 붙여 validateStudent 함수로 넘어간 Student 객체가 변할지도 모른다는 걱정을 호출부가 하지 않도록 함.
            - 추가설명
                
                ## 1. 값 전달 vs 참조 전달
                
                ```cpp
                bool validateStudent(Student s);          // 값 전달
                bool validateStudent(const Student& s);   // 참조 전달 + const
                
                ```
                
                - **값 전달**
                    
                    `plato`를 복사해서 함수 안에서만 쓰는 `s`라는 별도 객체가 생김.
                    
                    → 원본(`plato`)은 아무리 `s`를 바꿔도 영향 없음.
                    
                - **참조 전달**
                    
                    `plato` 자체를 함수 안에서 `s`라는 다른 이름으로 바라봄.
                    
                    → `s`를 바꾸면 `plato`가 바뀜. (원본이 그대로 드러남)
                    
                
                그래서 단순히 `Student& s`로 받으면:
                
                ```cpp
                bool validateStudent(Student& s) {
                    s.schoolName = "악의적인 변경";  // 원본도 같이 바뀜
                    return true;
                }
                ```
                
                → 호출자는 "검증만 하는 함수일 줄 알았는데, 데이터를 바꿔버리네?" 하는 불안이 생김.
                
                ---
                
                ## 2. `const`를 붙이면?
                
                ```cpp
                bool validateStudent(const Student& s);
                ```
                
                - `s`는 `plato`의 별칭이지만,
                - `const` 때문에 `s`를 통해 원본 내용을 바꿀 수 없음.
                - 즉, 호출자 입장에서는 "내가 준 원본 객체가 함수 안에서 망가지지 않는다"라는 **안전 보장**을 받음.

## 2) 참조 전달의 장점

### (1) 복사손실 문제 (slicing problem) 가 없어진다

```cpp
class Window {
public:
    ...
    std::string name() const;         // 윈도우의 이름을 반환합니다.
    virtual void display() const;     // 윈도우 테두리 및 내부를 그립니다.
};

class WindowWithScrollBars: public Window {
public:
    ...
    virtual void display() const;
};

```

- 잘못 구현된 코드 먼저 ,
    
    ```cpp
    void printNameAndDisplay (Window w) // 매개변수가 복사 손실됨
    { 
    	std：:cout << w.name( ) ； 
    	w.display( ) ；
    }
    ```
    
    - 이렇게 구현된 코드에 WindowWithScrollBars 객체를 넘기면,
    
    ```cpp
    WindowWithScrollBars wwsb;
    printNameAndDisplay(wwsb);
    ```
    
    - 매개변수 w는 Window 객체로 만들어지면서, printNameAndDisplay 안에서 호출되는 display는 Window::display 일것.

- 복사 손실 문제가 일어나지 않게 하려면 w를 상수객체에 대한 참조자로 전달하도록 만들면 됨.
    
    ```cpp
    void printNameAndDisplay(const Window& w)   //이제 매개변수는
    {                                           //잘리지 않습니다.
        std::cout << w.name();
        w.display();
    }
    ```
    
    - w는 어떤 종류의 윈도우가 넘겨지더라도 그 윈도우의 성질을 그대로 갖게 됨.
    - 참조자를 전달한다는 것은 결국 포인터를 전달한다는 것’
    - 전달하는 객체의 타입이 기본제공 타입(int 등)일 경우에는 참조자로 넘기는 것보다 값으로 넘기는 편이 더 휴울적일때가 많음.
        - ‘값에 의한 전달’ 및 ‘상수객체의 참조에 의한 전달’ 중 하나를 선택 해야 할때,
            - 기본 제공 타입인 경우에는 ‘값에 의한 전달’을 선택하는 것도 가능
            - STL의 반복자의 함수 객체에도 마찬가지.