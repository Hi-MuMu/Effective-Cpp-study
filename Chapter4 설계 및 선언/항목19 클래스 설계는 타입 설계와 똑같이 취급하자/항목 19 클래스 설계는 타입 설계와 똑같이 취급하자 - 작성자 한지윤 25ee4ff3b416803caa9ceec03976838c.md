# 항목 19: 클래스 설계는 타입 설계와 똑같이 취급하자 - 작성자: 한지윤

<aside>
🔎

# 이것만은 잊지말자!

- 클래스 설계는 타입 설계입니다. 새로운 타입을 정의하기 전에, 이번 항목에 나온 모든 고려사항을 빠짐없이 점검해 보십시오.
</aside>

---

# 📌 타입 설계자

- C++에서 **클래스를 정의한다는 건 새로운 타입을 만드는 것**과 같다.
- 따라서 클래스 설계자는 사실상 **타입 설계자(type designer)**이며, 언어 설계자만큼 큰 권한을 가진다.
    - 연산자 오버로딩
    - 메모리 할당/해제 제어
    - 객체 초기화/종료 과정 제어
        
        → 이런 것들이 모두 설계자의 손에 달려 있다.
        
- 좋은 타입은…
    1. **문법(syntax)** 이 자연스럽고
    2. **의미구조(semantics)** 가 직관적이며
    3. **효율적 구현** 이 가능해야 함.
- 하지만 C++에서는 이 세 가지를 동시에 만족하기 쉽지 않음
    
    → 예: 멤버 함수조차 어떻게 선언하느냐에 따라 성능이 달라질 수 있음
    
- 따라서 클래스 설계 시에는 **기본 타입을 설계하듯이 꼼꼼하고 신중하게 접근**해야 하며,
    
    효율성과 사용성 모두 고려해 질문과 검토 과정을 거쳐야 한다
    

# **📌 신경쓰면 좋은 부분들**

**1. 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야하는가? (항목 8)**

- 객체 생성과 소멸에 따라 생성자와 소멸자의 설계가 바뀌게 됩니다. 
그 뿐 아니라 메모리 할당 함수를 직접 작성하는 경우에도 함수의 설계에 영향을 미칩니다.
- 메모리 할당
    
    ```cpp
    operator new, operator new[], operator delete, operator [] delete
    ```
    

**2. 객체 초기화는 객체 대입과 어떻게 달라야하는가? (항목 4)**

- 생성자와 대입 연산자의 동작 짓는 부분은 함수 호출 부분입니다. 즉, 생성자는 클래스와 동일한 이름의 함수를 불러주는 것을 말합니다. 반면에, 대입 연산자는 클래스를 인자로 전달받도록 합니다.

**3. 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?**

- 어떤 타입에 대해 ‘값에 의한 전달’을 구현하는 쪽은 복사 생성자입니다.

**4. 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?**

- 전부는 아니지만, 클래스의 데이터 멤버의 몇 가지 조합 값 만은 반드시 유효해야 합니다. 이런 조합을 가리켜 불변속성이라고 부릅니다.
- 불변속성에 따라, `생성자`, `대입 연산자`, `각종 쓰기(setter)` 함수와 같이 적법한 값인지에 대한 점검 루틴이 포함되어져야 한다.

**5. 기존의 클래스 상속 계통망에 맞출 것인가? (항목 7, 항목 34, 항목 36)**

- 이미 갖고 있는 상속을 시킨다고 하면, 기반 클래스에 따라 제약이 좌지우지 됩니다. 특히, 멤버 함수가 가상인가 비가상인가의 여부가 가장 큰 요입니다. 특히, 소멸자가 그렇습니다.
- ‘is-a’ 관계를 만족하는지 확인
    - 단순히 코드 재사용을 위해 상속을 남용하면 유지보수가 어려워짐

**6. 어떤 종류의 타입 변환을 허용할 것인가? (항목 15)**

- C++에서 타입 변환 할 수 있는 방법은 **명시적 변환**과 **암시적 변환** 두 가지로 나뉘게 됩니다.
- 문자 그대로 **명시적 변환은 사용자의 직접 호출**로만 변환되도록 해야 하며, 임의로 컴파일러가 변환하면 안됩니다. 해당 변환을 동작 시키기 위해서는 **암시적 변환을 허용하지 않으면 안된다**.
- `C++11 에서는 explicit이라는 키워드`를 적어주면 된다. 이전 버전에서는 operator 재정의를 하지 않고, 생성자로 변환될 수 있는 타입을 만들어 주지 않는 방법으로 해결하였습니다
- 구체적으로, T1 타입과 T2 타입이 존재한다고 가정합니다.
    - T1 타입을 T2 타입으로 암시적 변환을 하고 싶다면, **operator T2()라는 함수를 재정의**해 암시적으로 변환하게 해주거나 생성자에 **T2인자를 이와 같이 public T1(T2 t)**전달받도록 만들면 됩니다.
    - 두 가지 방법을 모두 적용하지 않고 **오로지 타입에 getter로만 접근**하도록 한다면 **명시적 변환만 허용**한다고 볼 수 있습니다.

**7. 어떤 연산자와 함수를 두어야 의미가 있을까? (항목 23, 항목 24, 항목 46)**

- 클래스 안에 **선언할 함수가 바로 여기서 결정**됩니다. 어떤 것이 **멤버 함수로 적당**한지, **일반 함수로 적**당한지 구별해야 합니다.

**8. 표준 함수들 중 어떤 것을 허용하지 말아야하는가? (항목 6)**

- 외부에서 사용하지 못하도록 하려면, private에 선언 하라.

**9. 새로운 타입의 멤버에 대한 접근 권한을 어느 쪽에 줄 것인가?**

- 설계 시, 어떤 클래스 멤버를 `public`, `private`, `protected`영역에 둘 것인가 고민해야합니다. 또한, friend 함수를 비롯해 한 클래스가 다른 클래스에 중첩되도 되는가에 대해서도 고민해야 합니다.
- **`friend keyword`**되도록 안쓰는 것이 좋음.

**10. ‘선언되지 않은 인터페이스’로 무엇을 둘 것인가? (항목 29)**

- 설계 시, 만들 타입이 제공할 보장이 “어떤 종류일까?”에 대해 고민 해봐야 한다는 말입니다. 
예를 들어, 보장할 수 있는 부분은 수행 성능 및 예외 안전성 그리고 자원 사용입니다. 그렇다면 클래스 구현에 있어서 해당 부분들을 보장해야 되기 때문에 제약으로 작용합니다.

**11. 새로 만드는 타입이 얼마나 일반적인가?**

- 실상은 타입 하나를 정의하는 것이 아닐지 모릅니다.
- 즉, 동일 계열 타입군 전체라면, `template`으로 구현 하는 것이 좋습니다.

**12. 정말로 꼭 필요한 타입인가?**

- 기존의 클래스에 대해 기능 몇 개가 아쉬워 파생 클래스를 만들고 있다면, 간단하게 **비멤버 함수**라든지 **템플릿을 몇 개 더 정의**하는 것이 낫습니다.