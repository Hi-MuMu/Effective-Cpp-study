# 항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자: 고형주

<aside>
🔎

# 이것만은 잊지말자!

- 소멸자에서는 예외가 빠져나가면 안됩니다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜버리든지 프로그램을 끝내든지 해야 합니다.
- 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 합니다.
</aside>

---

<aside>

# 📌 소멸자로부터 생기는 예외는 직접 막아야 한다.

</aside>

```cpp
class Widget {
	public:
		...
		~Widget() { ... }             // 이 함수로부터 예외가 발생되면
};

void doSomething() 
{
	std::vector<Widget> v;
	...
}                               // v는 여기서 소멸
```

벡터 v가 위와는 다르게 10개가 생성되었고 첫번째 Widget을 소멸시키는 과정에서 예외가 발생했다고 가정하자. 이때 나머지도 소멸되어야 하는데 두 번째 Widget가 소멸되면서 또 예외가 생기면, 프로그램이 정의되지 않은 동작을 보일 수 있다. (두 개의 예외가 동시에 활성화 되므로 프로그램이 terminate()를 호출)

이 문제는 예외 발생에 아무런 대처를 하지 않은 소멸자에게 있으므로 배열이나 컨테이너를 써도 결과는 마찬가지이다.

이러한 문제를 해결하기 위해서 개발자는 **사용자에게 에러를 처리할 수 있는 기회를 주어야 한다.**

---

<aside>

# 📌 예외를 던지는 소멸자

</aside>

```cpp
class DBConn {  // DBConnection 객체를 관리하는 클래스
	public:
		...
		
		~DBConn()   // 데이터베이스 연결이 항상 닫히도록 확실히 챙겨주는 함수
		{
			db.close();
		}
	
	private:
		DBConnection db;
};

class DBConnection {
	public:
		...
		static DBConnection create();  // DBConnection 객체를 반환하는 함수
																	 // 매개변수는 편의상 생략
		
		void close();                  // 연결을 닫습니다.
																	 // 이때 연결이 실패하면 예외를 던집니다.
};

{                                      // 블록 시작
	DBConn dbc(DBConnection::create());  // DBConnection 객체를 생성하고
	                                     // DBConn으로 넘겨서 관리를 맡깁니다.
	                                     
	                                     // DBConn 인터페이스를 통해
	                                     // 그 DBConnection 객체를 사용합니다.
	                                     
	                                     // 블록 끝. DBConn 객체가
	                                     // 여기서 소멸됩니다. 따라서
	                                     // DBConnection 객체에 대한 close
	                                     // 함수의 호출이 자동으로 이루어집니다.
}
```

위 코드는 close 호출만 성공하면 문제될 것이 없다. 

그러나 **close()에서 다음과 같은 경우로 예외가 발생할 수 있다.** 

- 네트워크 연결 끊김
- 데이터베이스 서버 다운
- 권한 문제로 연결 종료 실패

close를 호출했는데 예외가 발생하면 DBConn의 소멸자는 예외를 전파한다. 이렇게 소멸자에서 예외가 나가도록 방치하면 문제를 발생시킬 수 있다. 문제를 방지하기 위해 두 가지 방법을 사용할 수 있다. 

## 1️⃣ 첫 번째 방법:

### close에서 예외가 발생하면 프로그램을 즉시 종료 (abort 사용)

```cpp
DBConn::~DBConn()
{
	try { db.close(); }
	catch (...) {
	  close 호출이 실패했다는 로그를 작성합니다;
		std::abort();
	}
}
```

### ⭕ 장점:

객체 소멸 진행 중의 에러로 인한 예외를 방치했을 때 정의되지 않은 동작에 이를 수 있다면, 프로그램을 끝내게 한다는 점에서 좋은 선택이다. 데이터 무결성이 중요하거나 예외를 무시하면 더 큰 문제가 생길 때 사용하면 좋다.

### ❌ 단점:

당연하게도 프로그램이 갑자기 꺼진다.

## 2️⃣ 두 번째 방법:

### close를 호출한 곳에서 일어난 예외를 삼킨다. (무시하기)

```cpp
DBConn::~DBConn()
{
	try { db.close(); }
	catch (...) {
	  close 호출이 실패했다는 로그를 작성합니다;
	  // std::abort(); // abort를 사용하지 않는다.
	}
}
```

### ⭕ 장점:

상황에 따라서는 불완전한 프로그램 종료나 미정의 동작으로 인해 입는 위험을 감수하는 것보다, 예외를 무시하는 것이 나을 수 있다. (단, 예외를 무시하고도 프로그램이 안정적으로 동작해야 한다. ) 그러므로 프로그램이 계속 실행되는 것이 중요하거나 해당 오류가 치명적이지 않을 때 사용한다.

### ❌ 단점:

대부분의 경우에서 예외를 무시하면 중요한 오류 정보를 놓칠 수 있기 때문에 좋은 방법이 아니다.  

### ✅ 결국, 위 두 방법 중에서 우월한 선택지는 없다.

---

<aside>

# 📌 문제에 대처할 기회를 사용자에게 주기

</aside>

객체를 관리할 인터페이스를 잘 설계해서 발생할 소지가 있는 문제에 대해 대처할 기회를 사용자에게 주는 방법을 사용할 수 있다. 

에러가 발생할 수 밖에 없다면, 해당 에러를 방치하는 것보다 선택권을 사용자에게 주는 편이 낫다.

```cpp
class DBConn {  // DBConnection 객체를 관리하는 클래스
	public:
		...
		
		void close()
		{
			db.close();
			closed = true;
		}
		
		~DBConn()   // 데이터베이스 연결이 항상 닫히도록 확실히 챙겨주는 함수
		{
			if (!closed)
			
			// 사용자가 연결을 안 닫았으면 여기서 닫기 시도를 합니다.
			try {              
			  db.close();
			}
			
			// 연결을 닫다가 실패하면 실패를 알린 후에 실행을 끝내거나 예외를 삼킵니다.
			catch (...) {
			
			  close 호출이 실패했다는 로그를 작성합니다;
			  ...
			}
		}
	
	private:
		DBConnection db;
		bool closed = false;
};
```

위와 같이 객체를 관리하는 클래스에서 close 함수를 제공한다면, 클래스의 함수 실행 중에 발생하는 예외를 사용자가 직접 처리할 수 있다. 

이를 통해 클래스가 닫혔는지 여부를 유지했다가 닫히지 않았으면 사용자가 객체를 관리하는 클래스의 소멸자에서 닫을 수도 있다.

하지만 close가 되지 않아 예외가 발생하면, 소멸자가 프로그램을 끝내거나 무시하거나 둘 중 하나를 선택할 수 밖에 없다.

---

<aside>

# 📌 선택권을 넘기는 것은 무책임하지 않다.

</aside>

특정 동작이 예외를 일으키면서 실패할 가능성과 예외를 처리해야 할 필요가 있다면, **그 예외는 소멸자가 아닌 다른 함수에서 비롯되어야 한다.**

선택권을 통해 사용자에게 에러를 처리할 수 있는 기회가 주어진 것이다. 

이 선택권을 무시하면 객체를 관리하는 클래스에서 어떻게 에러를 처리하든, 일단 개발자는 사용자에게 선택권을 주었으므로  책임을 덜게 된다.

---

<aside>

# 📌 예외 처리 방법 비교와 최종 정리

</aside>

| 방법 | 장점 | 단점 | 적용 상황 |
| --- | --- | --- | --- |
| abort() 호출 | 미정의 동작 방지 | 프로그램 강제 종료 | 데이터 무결성이 중요할 때 |
| 예외 흡수 | 프로그램 계속 실행 | 오류 정보 손실 | 프로그램 안정성이 우선일 때 |
| 사용자 선택권 | 유연한 오류 처리 | 구현 복잡도 증가 | 이상적인 설계 |

### 최종 정리

- **소멸자에서는 절대 예외를 밖으로 내보내지 말자**
- **예외가 날 수 있는 작업은 일반 함수로 제공하자**
- **사용자에게 직접 처리할 기회를 주는 것이 최선이다**