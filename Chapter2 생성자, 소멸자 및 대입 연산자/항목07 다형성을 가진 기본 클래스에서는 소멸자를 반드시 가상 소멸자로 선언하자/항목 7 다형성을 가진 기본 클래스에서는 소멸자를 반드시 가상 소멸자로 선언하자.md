# 항목 7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자 - 작성자: 고형주

<aside>
🔎

# 이것만은 잊지말자!

- 다형성을 가진 기본 클래스에서는 반드시 가상 소멸자를 선언해야 합니다. 즉, 어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자이어야 합니다.
- 기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 합니다.
</aside>

---

<aside>

# 📌 비가상 소멸자의 문제

</aside>

```cpp
class TimeKeeper {
  public:
	  TimeKeeper();
	  ~TimeKeeper();
	  ...
};

class AtomicClock : public TimeKeeper {
	public:
	    AtomicClock() { data = new int[1000]; }  // 메모리 할당
	    ~AtomicClock() { delete[] data; }        // 메모리 해제
	private:
	    int* data;
};

class WaterClock: public TimeKeeper { ... };

class WristWatch: public TimeKeeper { ... };

TimeKeeper* getTimeKeeper(); // TimeKeeper에서 파생된 클래스를 통해
                             // 동적으로 할당된 객체의 포인터를 반환합니다.

// 팩토리 패턴
TimeKeeper* getTimeKeeper() {
    return new AtomicClock();  // 파생 클래스 객체 반환
}
                             
TimeKeeper *ptk = getTimeKeeper(); // TimeKeeper 클래스 계통으로부터
                                   // 동적으로 할당된 객체를 얻습니다.
                                   
...                                // 이 객체를 사용합니다.

delete ptk;                        // 자원 누출을 막기 위해 해제(삭제)합니다.
```

위와 같이 시간 정보에 접근할 수 있는 기본 클래스와 파생된 클래스가 있다고 생각해보자.

시간 기록 객체에 대한 포인터를 손에 넣는 용도로 팩토리 함수를 만들어 두면 좋다.

팩토리 함수의 규약에 따라 getTimeKeeper 함수에서 반환되는 객체는 힙에 있게 된다.

이때, **메모리 및 기타 자원의 누출을 막기 위해 해당 객체를 적절히 삭제해야 한다.**

## 🚨 문제 사항

1. getTimeKeeper 함수가 반환하는 포인터가 파생 클래스(AtomicClock 같은 것들) 객체에 대한 포인터
    - `ptk`는 `TimeKeeper*` 타입 (기본 클래스 포인터)
    - 실제로는 `AtomicClock` 객체를 가리킴 (파생 클래스 객체)
2. 파생 클래스 객체에 대한 포인터가 가리키는 객체가 삭제될 때는 기본 클래스 포인터(TimeKeeper*)를 통해 삭제
    - `delete ptk` 실행 시, **TimeKeeper의 소멸자만 호출됨**
3. 기본 클래스(getTimeKeeper)에 들어 있는 소멸자가 비가상 소멸자(non-virtual destructor)
    - **AtomicClock의 소멸자는 호출되지 않음** → 메모리 누수!

## 🔔 **C++ 규정:**

기본 클래스 포인터를 통해 **파생 클래스 객체가 삭제될 때, 그 기본 클래스에 비가상 소멸자가 들어 있으면 프로그램 동작은 미정의(Undefined Behavior)**이다. (대개 그 객체의 파생 클래스 부분이 소멸하지 않게 된다.)

## 💥 결과

getTimeKeeper 함수에서 포인터를 통해 오는 AtomicClock 객체는 기본 클래스 포인터를 통해 삭제

→ AtomicClock 부분이 종료되지 않으니 AtomicClock의 소멸자도 실행되지 않음

→ 기본 클래스 부분(timeKeeper)은 소멸 과정이 끝남

→ 객체가 부분적으로만 소멸

→ 자원 누수, 자료구조 오염

→ 디버깅해야 함

<aside>

# 📌 비가상 소멸자의 문제 해결 방법

</aside>

## ✨ 해결 방법: 기본 클래스에 가상 소멸자 추가

이렇게 하면 파생 클래스 개체를 기본 클래스 포인터로 삭제할 때 객체 전부가 소멸되게 된다.

```cpp
class TimeKeeper {
  public:
	  TimeKeeper();
	  virtual ~TimeKeeper();  // <--- **가상 소멸자 추가**
	  ...
};

class AtomicClock : public TimeKeeper {
	public:
	    AtomicClock() { data = new int[1000]; }
	    ~AtomicClock() { delete[] data; }  // 이제 제대로 호출됨!
	private:
	    int* data;
};

class WaterClock: public TimeKeeper { ... };

class WristWatch: public TimeKeeper { ... };

                             
TimeKeeper *ptk = getTimeKeeper(); // TimeKeeper 클래스 계통으로부터
                                   // 동적으로 할당된 객체를 얻습니다.
                                   
...                                // 이 객체를 사용합니다.

delete ptk;                        // 모든 객체가 정상적으로 소멸!
```

파생 클래스를 구현할 때 해당 함수를 역할에 따라 맞추는 것이 허용되기 때문에, 기본 클래스에는 소멸자 외에도 가상 멤버 함수들이 들어 있는 경우가 있다. 어쨌든 가상 함수를 하나라도 가진 클래스는 가상 소멸자를 가져야 한다.

## **소멸자 호출 순서**

1. 먼저 `AtomicClock::~AtomicClock()` 호출
2. 그 다음 `TimeKeeper::~TimeKeeper()` 호출
3. 메모리 누수 없음

<aside>

# 📌 가상 소멸자를 쓰면 안되는 경우

</aside>

## vptr(가상함수 테이블 포인터)로 인한 크기 증가

예를 들어 다음 클래스를 보자.

```cpp
// 비가상 소멸자 사용
class Point {
public:
    Point(int xCoord, int yCoord);
    ~Point();  // 비가상 소멸자
private:
    int x, y;  // 각각 32비트 = 총 64비트
};

// 만약 가상 소멸자를 추가하면?
class Point {
public:
    Point(int xCoord, int yCoord);
    virtual ~Point();  // X 불필요한 가상 소멸자
private:
    int x, y;  // 64바이트
    // + vptr 포인터 64비트 (64비트 시스템) = 총 128비트
};
```

int가 32비트를 차지한다면, 이 Point 객체는 2개의 int 변수를 쓰므로 64비트 레지스터에서 사용할 수 있다. 그러나 Point 클래스의 소멸자가 가상 소멸자로 만들어지면 문제가 생긴다.

가상 함수를  C++에서 구현하려면 클래스에 별도의 자료구조가 하나 들어가야 하는데, 프로그램 실행 중에 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지 결정하는 정보가 필요하기 때문이다.

이 정보는 **vptr(가상 함수 테이블 포인터)**이고 포인터의 형태를 가진다. vptr은 가상 함수의 주소(포인터들의 배열)을 가리키며 가상 함수 테이블 포인터의 배열은 **vtbl(가상 함수 테이블)**이라고 불린다. 

가상 함수를 하나라도 갖고 있는 클래스는 반드시 그와 관련된 vtbl을 가지고 있다. 어떤 객체에 대해 특정 가상 함수가 호출되려고 하면, 호출되는 실제 함수는 그 객체의 vptr이 가리키는 vtbl에 따라 결정된다. vtbl에 있는 함수 포인터 중 적절한 포인터가 연결되는 것이다.

여기서 중요한 점은 **Point 클래스에 가상 함수가 들어가게 되면 Point 타입의 크기가 커진다**는 점이다. 

1. 프로그램 실행환경이 **32비트** 아키텍처인 경우
    - 크기가 64비트에서 96비트(int 2개, vptr 1개)로 커진다.
2. 프로그램 실행환경이 **64비트** 아키텍처
    - 크기가 64비트에서 128비트(int 2개, vptr 1개)로 커진다.
    - 64비트 시스템에서 포인터 크기는 64비트이기 때문

## 🚨 **문제점**

1. **메모리 사용량 2배 증가** (8바이트 → 16바이트)
2. **다른 언어와 호환성 문제** (C 구조체와 호환 불가)
3. **레지스터 최적화 불가** (64비트 레지스터에 안 들어감)

이렇게 되면 64비트 레지스터에 프로그램이 들어갈 수 없다.

다른 언어로는 vptr를 만들 수 없기 때문에 동일한 자료구조와도 호환성이 없어진다.

결국  다른 언어로 작성된 함수에 Point  객체를 전달하고 그 함수로부터 전달받을 수 있게 하려면 vptr 부분을 보충해야 한다. 그러나 이는 구현환경에 따라 세부사항이 달라지므로 이식성은 낮아진다.

## 🎯 결론

모든 경우에 소멸자를 전부 virtual로 **선언하지 않는** 일은 좋지 않다.

모든 경우에 소멸자를 전부 virtual로 **선언하는** 일은 좋지 않다.

**가상 함수가 하나라도 있는 클래스만, 가상 소멸자를 선언해야 한다.**

 

<aside>

# 📌 가상 함수 없이도 비가상 소멸자 문제는 발생 가능

</aside>

**STL 컨테이너들의 공통점:**

- `std::string`, `std::vector`, `std::list` 등
- **모두 가상 소멸자가 없음**
- **상속을 받으면 안 됨**

표준 `string` 타입은 가상 함수를 가지고 있지 않다.

```cpp
// 하면 안 되는 코드
class SpecialString : public std::string {
  // std::string은 가상 소멸자가 없음!
	private:
	    int* extraData;
	public:
	    SpecialString() { extraData = new int[100]; }
	    ~SpecialString() { delete[] extraData; }
};

// 위험한 사용법
SpecialString* pss = new SpecialString("Hello");
std::string* ps = pss;  // 업캐스팅 (강제 변환)
delete ps;  // std::string 소멸자만 호출 → extraData 메모리 누수!
```

**String은 가상 소멸자가 없다**. 그러므로 이것을 사용한 응용 프로그램 어딘가에서 SpecialString의 포인터를 string의 포인터로 강제로 변환하여 string 포인터(ps)에 delete를 적용하면 어떤 일이 일어날지 모른다.

```cpp
SpecialString *pss = new SpecialString("Impending Doom");

std::string *ps;
...
ps = pss;          // SpecialString* => std::string*
...
delete ps;         // 정의되지 않은 동작 발생
                   // 실질적으로는 *ps의 SpecialString 부분에 있는 자원이 누출되는데,
                   // SpecialString의 소멸자가 호출되지 않기 때문이다.
```

이러한 현상은 가상 소멸자가 없는 클래스면 전부 발생할 수 있다. 

## 🎯 결론

 STL 컨테이너 타입은 전부 가상 소멸자가 없는 클래스이다. 그러므로 비가상 소멸자를 가진 표준 컨테이너 등의 클래스를 써서 개인적인 클래스를 만드는 것은 자제하면 좋다.

<aside>

# 📌 순수(pure) 가상 소멸자

</aside>

## 순수 가상 소멸자

어떤 클래스가 추상 클래스였으면 좋겠는데 다른 순수 가상 함수가 필요 없을 때, 추상 클래스로 만들고 싶은 클래스에 **순수 가상 소멸자를 선언**하면 된다.

### 참고

**순수 가상 함수**는 해당 클래스를 추상 클래스(abstract class)로 만든다.

**추상 클래스**는 그 자체로는 인스턴스를 못 만드는(그 타입의 객체를 생성할 수 없는) 클래스이다.

## **순수 가상 소멸자를 선언하면 되는 이유**

추상 클래스는 기본 클래스로 쓰기 위해 만들어진 것

→ 기본 클래스로 쓰이려는 클래스는 가상 소멸자를 가져야 한다.

→ 순수 가상 함수가 있으면 바로 추상 클래스가 된다.

→ 추상 클래스에 순수 가상 소멸자를 선언하면 추상 클래스가 된다.

```cpp
class AWOV {  // Abstract Without Other Virtuals
	public:
	    virtual ~AWOV() = 0;  // 순수 가상 소멸자 선언
};

// 필수: 순수 가상 소멸자의 정의
AWOV::~AWOV() {
    // 기본 클래스 소멸자는 항상 호출되기 때문
}

class Derived : public AWOV {
	public:
	    ~Derived() {
	        // 소멸 순서: Derived::~Derived() → AWOV::~AWOV()
	    }
};

// AWOV awov;     // X 컴파일 에러 - 추상 클래스
// Derived d;     // OK
```

AWOV 클래스는 순수 가상 함수를 가지고 있으므로 추상 클래스이다.

순수 가상 함수가 가상 소멸자이므로 소멸자 호출 문제로 고민할 필요가 없음

그러나 순수 가상 소멸자의 정의를 선언해야 한다.

## 소멸자 동작 순서

1. 상속 계통 구조에서 가장 말단에 있는 **파생 클래스의 소멸자가 먼저 호출**
2. 기본 클래스 쪽으로 거쳐 올라가면서 **각 기본 클래스의 소멸자가 하나씩 호출**
3. 컴파일러는 ~AWOV의 호출 코드를 만들기 위해 **파생 클래스의 소멸자를 사용**
4. **`AWOV::~AWOV()`의 본문이 없으면 링커 에러 발생**

 

### ✅ 가상 소멸자가 필요한 경우

```cpp
// 1. 다형성을 위한 기본 클래스
class Shape {
public:
    virtual void draw() = 0;  // 가상 함수 있음
    virtual ~Shape() {}       // → 가상 소멸자 필요
};

// 2. 인터페이스 클래스  
class IDatabase {
public:
    virtual void connect() = 0;
    virtual void query() = 0;
    virtual ~IDatabase() = 0;  // 순수 가상 소멸자
};
```

### ❌ 가상 소멸자가 불필요한 경우

```cpp
// 1. 값 타입 클래스
class Point { int x, y; };

// 2. 유틸리티 클래스
class MathUtils {
public:
    static double sqrt(double x);
};

// 3. RAII 클래스 (상속 목적 아님)
class FileHandle {
public:
    explicit FileHandle(const std::string& filename);
    ~FileHandle();  // 비가상 소멸자
};
```

**기본 클래스에 가상 소멸자를 추가하는 규칙은 다형성을 가진 기본 클래스에만 적용된다.** 여기서 말하는 기본 클래스는 기본 클래스 인터페이스를 통해 파생 클래스 타입의 조작을 허용하도록 설계된 기본 클래스를 말한다.

맨 처음의 TimeKeeper가 바로 이에 속한다. AtomicClock, WaterClock 등을 TimeKeeper 포인터만 있으면 조작할 수 있기 때문이다. 

모든 클래스가 다형성을 갖도록 설계된 것은 아니고, 기본 클래스로는 쓰일 수 있지만 다형성을 갖지 않도록 설계된 클래스도 있다. 이러한 클래스는 기본 클래스의 인터페이스를 통한 파생 클래스 객체의 조작이 허용되지 않으므로 가상 소멸자가 없다.