# 항목 5: C++가 은근슬쩍 만들어 호출해 버 리는 함수들에 촉각을 세우자 - 작성자: 권우현

<aside>

# 💡이것만은 잊지말자!

- 컴파일러는 경우에 따라 클래스에 대해 기본 생성자 복사 생성자 복사 대입 연산자, 소멸자
를 암시적으로 만들어 놓을 수 있습니다
</aside>

---

# 📘 C++ 특수 멤버 함수와 자동 생성

---

## 1. 클래스가 비어있지만 비어있는 게 아닌 경우

- C++의 어떤 멤버 함수는 클래스 안에 직접 선언하지 않으면 컴파일러가 저절로 선언해주도록 되어 있음
    1. 복사 생성자 (copy constructor)
    2. 복사 대입 연산자 (copy assignment operator)
    3. 소멸자 (destructor)

---

## 2. `class Empty {}` 와 기본 형태

```cpp
class Empty {};

```

- 멤버가 전혀 없는 **빈 클래스**
- 이 상태에서도 C++ 컴파일러는 필요에 따라 **특수 멤버 함수**를 자동으로 만들어줌

---

## 3. 컴파일러가 자동으로 만들어주는 특수 멤버 함수

| 멤버 함수 | 역할 | 조건 |
| --- | --- | --- |
| **기본 생성자** `Empty()` | 객체를 생성할 때 호출 | 사용자가 생성자를 정의하지 않으면 자동 생성 |
| **소멸자** `~Empty()` | 객체가 소멸될 때 호출 | 가상 함수가 없는 한 기본 소멸자를 자동 생성 |
| **복사 생성자** `Empty(const Empty& rhs)` | 객체를 다른 객체로 초기화할 때 호출 | 사용자가 복사 생성자를 정의하지 않으면 자동 생성 |
| **복사 대입 연산자** `Empty& operator=(const Empty& rhs)` | 이미 생성된 객체에 다른 객체를 대입할 때 호출 | 사용자가 정의하지 않으면 자동 생성 |

---

## 4. 예시 코드와 동작

```cpp
Empty e1;        // 기본 생성자 호출
Empty e2(e1);    // 복사 생성자 호출
e2 = e1;         // 복사 대입 연산자 호출

```

- `Empty`는 아무 멤버도 없지만, 컴파일러가 필요에 따라 생성자를 만들어줌
- “빈 클래스이지만 객체를 생성하고 복사할 수 있다”는 특징 존재

---

## 5. 핵심 포인트

1. **자동 생성 조건**: 사용자가 해당 특수 멤버 함수를 직접 정의하지 않은 경우 생성됨
2. **“필요할 때만” 생성**: 객체 생성, 복사, 대입 등으로 실제 사용될 때 컴파일러가 판단
3. **빈 클래스여도 안전하게 사용 가능**: 기본 생성자, 복사 생성자, 소멸자, 복사 대입 연산자가 자동 제공됨

---

## 6. 요약

> class Empty {} 와
> 
> 
> class Empty { public: Empty(){}; Empty(const Empty& rhs){}; ~Empty(){}; Empty& operator=(const Empty& rhs){}; };
> 
> 는 사실상 컴파일러가 자동으로 만들어주는 것과 동일
> 

---

## 7. 예제: NamedObject 템플릿

```cpp
template<typename T>
class NamedObject {
public:
    NamedObject(const std::string& name, const T& value);
private:
    std::string nameValue;
    T objectValue;
};

```

- **기본 생성자 없음** → 컴파일러는 기본 생성자를 만들지 않음
- **복사 생성자/복사 대입 연산자 없음** → 필요하면 자동 생성

```cpp
NamedObject<int> nol("Prime", 2);
NamedObject<int> no2(nol);  // 복사 생성자 호출
no2 = nol;                  // 복사 대입 연산자 호출

```

- 내부 동작:
    1. `std::string` → 자체 복사 생성자 호출
    2. `int` → 비트 단위 복사

---

## 8. 자동 생성이 불가능한 경우

- 아래 경우 자동 생성 불가 → 직접 정의 필요

| 상황 | 이유 |
| --- | --- |
| 멤버가 **상수(`const`)** | 복사 후 수정 불가 |
| 멤버가 **참조자(`&`)** | 참조는 다른 객체를 가리키도록 바꿀 수 없음 |
| 기본 클래스의 복사 대입 연산자가 **private** | 접근 불가 |
| 사용자 정의 생성자가 있어 **기본 생성자 필요 조건을 만족하지 않는 경우** | 컴파일러는 기본 생성자 생성하지 않음 |

```cpp
template<class T>
class NamedObject {
    std::string& nameValue;   // 참조자
    const T objectValue;      // 상수
};

```

→ 자동 복사 대입 연산자는 생성 불가 → 직접 정의 필요

---

## 9. 상황 설명

```cpp
template<class T>
class NamedObject {
public:
    NamedObject(std::string& name, const T& value);
private:
    std::string& nameValue;  // 참조자 멤버
    const T objectValue;     // 상수 멤버
};

```

- `nameValue` → 참조자(`&`)
- `objectValue` → 상수(`const`)
- **복사 대입 연산자 `operator=` 미선언**

---

## 10. 대입 연산 시 문제 발생 이유

```cpp
std::string newDog("Persephone");
std::string oldDog("Satch");

NamedObject<int> p(newDog, 2);
NamedObject<int> s(oldDog, 36);

p = s;  // 복사 대입 시도

```

- p와 s는 각기 다른 string 참조
- 참조자와 상수 멤버가 문제를 일으킴

### 10-1. 참조자 문제

- 참조자는 초기화 후 다른 객체 참조 불가
- `p.nameValue = s.nameValue;` 불가 → 자동 복사 대입 연산자 동작 불가 → 컴파일러 에러

### 10-2. 상수 멤버 문제

- 상수 멤버는 값 변경 불가
- 자동 복사 대입 연산자는 덮어쓰기 방식 → 수행 불가 → 컴파일러 에러

---

## 11. 결론: 자동 생성 연산자가 불가능한 경우

- 자동 복사 대입 연산자 정상 동작 조건:
    1. 참조자 멤버 없어야 함
    2. 상수 멤버 없어야 함
    3. 기본 클래스의 복사 대입 연산자 접근 가능

> 하나라도 조건 불만족 시 컴파일러는 자동 생성 대신 에러 → 개발자가 직접 정의 필요
> 

---

## 12. 요약: “왜 컴파일러가 거부하는가?”

| 멤버 타입 | 문제점 | 결과 |
| --- | --- | --- |
| 참조자 | 이미 참조된 객체를 다른 객체로 바꿀 수 없음 | 자동 복사 대입 불가 |
| 상수 | 값을 덮어쓸 수 없음 | 자동 복사 대입 불가 |
| private 기본 클래스 멤버 | 접근 권한 없음 | 자동 복사 대입 불가 |
- 자동 생성 연산자는 **단순 멤버별 대입만 가능** → 참조자/상수 멤버는 지원 불가 → 직접 정의 필요

---

## 13. 해결 방법

```cpp
template<class T>
class NamedObject {
public:
    NamedObject(std::string& name, const T& value)
        : nameValue(name), objectValue(value) {}

    // 직접 복사 생성자 정의
    NamedObject(const NamedObject& other)
        : nameValue(other.nameValue), objectValue(other.objectValue) {}

    // 복사 대입 연산자 정의
    NamedObject& operator=(const NamedObject& other) {
        // nameValue와 objectValue는 수정 불가 → 대입 불가
        // 필요하면 멤버를 값 타입으로 바꾸어야 함
        return *this;
    }

private:
    std::string& nameValue;
    const T objectValue;
};

```

- 핵심: 자동 생성 연산자는 **단순 복사만 가능** → 참조자/상수 멤버는 지원 불가