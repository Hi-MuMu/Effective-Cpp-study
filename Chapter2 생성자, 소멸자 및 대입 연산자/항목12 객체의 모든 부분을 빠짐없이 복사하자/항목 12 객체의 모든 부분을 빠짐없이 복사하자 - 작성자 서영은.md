# 항목 12: 객체의 모든 부분을 빠짐없이 복사하자 - 작성자: 서영은

<aside>

# 💡이것만은 잊지말자!

- 객체 복사 함수는 주어진 객체의 모든 데이터 멤버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사해야 함
- 클래스의 복사 함수 두 개를 구현할 때, 한쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 말자.
대신, 공통된 동작을 제3의 함수에 분리해 놓고 양쪽에서 그것을 호출하게 만들어서 해결하자.
</aside>

---

# 📌 객체 복사 함수 사용 시 유의할 점

`객체 복사 함수(copying function)`란? 복사 생성자와 복사 대입 연산자를 통틀어 부름.

```cpp
void logCall(const std::string& funcName); // 로그 기록 내용을 만듦

class Customer {
public:
	...
	Customer(const Customer& rhs);
	Customer& operator=(const Customer& rhs);
	...
	
private:
	std::string name;
	Date lastTransaction;
};

Customer::Customer(const Customer& rhs)
: name(rhs.name) // rhs의 데이터를 복사
{
	logCall("Customer copy constructor");
}

Customer& Customer::operator=(const Customer& rhs)
{
	logCall("Customer copy assignment operator");
	name = rhs.name;  // rhs의 데이터 복사
	return *this;
}
```

이러면 복사 함수의 동작은 **부분 복사(partial copy)**가 됨.

**주의⚠️** 컴파일러가 경고를 하지 않음.

따라서, 클래스에 데이터 멤버를 추가했으면 추가한 데이터 멤버를 처리하도록 복사 함수를 재작성해야 함.

- 최신 컴파일러에서는 초기화하라고 경고합니다. 초기화 해주면 경고 사라짐.
    
    ![image.png](image.png)
    

## 클래스 상속이 추가된 경우

```cpp
class PriorityCustomer: public Customer { 
public:
	...
	PriorityCustomer(const PriorityCustomer& rhs); // 파생 클래스
	PriorityCustomer& operator=(const PriorityCustomer& rhs);
	...

private:
	int priority;
};

PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs)
: priority(rhs.priority)
{
	 logCall("PriorityCustomer copy constructor");
}

PriorityCustomer& PriorityCustomer::operator=(const PriorityCustomer& rhs)
{
	logCall("PriorityCustomer copy assignment operator");
	priority = rhs.priority; 
	return *this;
 }
```

PriorityCustomer에 선언된 데이터 멤버를 모두 복사하고 있지만, Customer로부터 상속한 데이터 멤버들은 복사가 안 되고 있음.

- 복사 생성자의 문제점
    - 기본 클래스 생성자에 넘길 인자가 명시되어 있지 않음
    - 따라서, PriorityCustomer 객체의 Customer 부분은 인자 없이 실행되는 Customer 생성자,
    즉 기본 생성자에 의해 초기화 됨.
- 복사 대입 연산자의 문제점
    - 기본 클래스의 데이터 멤버를 건드릴 시도도 하지 않기 때문에, 기본 클래스의 데이터 멤버는 변경되지 않고 그대로 있음.
    - 복사 생성자와 달리 컴파일러 단에서 기본 생성자를 만들지 않기 때문

## ✅ 해결 방법. 파생 클래스의 복사 함수 안에서 기본 클래스의 복사 함수를 호출

```cpp
PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs)
 : Customer (rhs), // 기본 클래스의 복사 생성자를 호출
	 priority(rhs.priority)
{
	logCall("PriorityCustomer copy constructor");
}

PriorityCustomer& PriorityCustomer::operator=(const PriorityCustomers&rhs)
{
	logCall("PriorityCustomer copy assignment operator");
	Customer::operator=(rhs); // 기본 클래스 부분을 대입
	priority = rhs.priority;
	return *this;
}
```

### **객체의 복사 함수를 작성할 때 꼭 확인할 두 가지**

- 해당 클래스의 데이터 멤버를 모두 복사
- 이 클래스가 상속한 기본 클래스의 복사 함수 호출

# 📌 복사 생성자와 복사 대입 연산자의 코드 중복

- 한 쪽에서 다른 쪽을 호출하게 만들어서 코드 중복을 피하는 건 안될까??

안됨. 복사 대입 연산자에서 복사 생성자를 호출하는 것부터 안됨. 이미 만들어져 존재하는 객체를 ‘생성’하고 있기 때문.

어떻게든 가능하게 할 수는 있으나, 특정한 조건에서 객체의 데이터가 훼손될 가능성이 있어서 매우 위험.

- 반대의 경우는 안되나요??

⇒ 안됩니다. 생성자의 역할은 새로 만들어진 객체를 초기화하는 것이지만, 대입 연산자의 역할은 ‘이미’ 초기화가 끝난 객체에게 값을 주는 것. 초기화된 객체에만 적용된다는 의미.

## ✅ 해결법

복사 생성자와 복사 대입 연산자의 겹치는 부분을 별도의 멤버 함수에 분리해 놓고, 그걸 호출하자!

대개 private 멤버로 두고 init어쩌고 이런 이름을 가짐.