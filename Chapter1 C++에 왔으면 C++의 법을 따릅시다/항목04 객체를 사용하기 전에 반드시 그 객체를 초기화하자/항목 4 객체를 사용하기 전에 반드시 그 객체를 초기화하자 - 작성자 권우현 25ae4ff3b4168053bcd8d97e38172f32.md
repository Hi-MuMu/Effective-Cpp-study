# 항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자 - 작성자: 권우현

<aside>

# 💡이것만은 잊지말자!

- 기본제공 타입의 객체는 직접 손으로 초기화 합니다. 경우데 따라 저절로 되기도 하고 안되기도 하기 때문입니다.
- 생성자에서는, 데이터 멤버에 대한 대입문은 생성자 본문 내부에 넣는 방법으로 멤버를 초기화 하지 말고 멤버 초기화 리스트를 즐겨 사용합시다. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열합시다.
- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서 문제는 피해서 설계해야 합니다. 비지역 정적 객체를 지역 정적 객체로 바꾸면 됩니다.
</aside>

---

## 1. 객체 초기화

객체의 값을 초기화 하는 C++의 규칙은 복잡함.

⇒ 어떤 상황에서는 초기화가 보장되지만 어쩔 때는 안됨.

그렇기 때문에 가장 좋은 방법은 모든 객체를 사용하기 전에 항상 초기화 하는 것이다.

```cpp
int x = 0;
const char * text = "A C-style string" j
double d;
std：：cin >> d;
// int의 직접 초기화
// 포인터의 직접 초기화
II (항목 3 도 참조)
// 입력 스트림에서 읽음으로써
// "초기화’' 수행
```

이 부분을 제외한 나머지 부분은 생성자 부분.

생성자에서 지킬 규칙은 그 객체의 모든 것을 초기화 하자! 만 지키면 됨.

---

## 2. 생성자(Constructor)

### 2-1. 정의

- **생성자(Constructor)** = 클래스의 특별한 멤버 함수로,
    
    객체가 **만들어질 때(생성될 때)** 자동으로 호출됨.
    
- 이름은 클래스 이름과 같고, **반환 타입이 없음**.

```cpp
class Person {
public:
    Person();              // 기본 생성자
    Person(std::string n); // 매개변수가 있는 생성자
};

```

---

### 2-2. 역할

1. **객체 초기화**
    - 객체가 만들어질 때 멤버 변수를 알맞게 초기화함.
    
    ```cpp
    class Person {
    public:
        Person(std::string n, int a) : name(n), age(a) {} // 초기화 리스트 사용
    private:
        std::string name;
        int age;
    };
    
    ```
    
2. **특별한 동작 수행**
    - 객체가 생성될 때 필요한 준비 작업 수행 가능 (예: 메모리 할당, 파일 열기 등).
3. **자동 호출**
    - `new` 연산자나 지역 변수 선언 시 자동으로 실행됨 → 직접 호출할 필요 없음.

---

### 2-3. 생성자의 종류

1. **기본 생성자 (Default Constructor)**
    - 매개변수가 없는 생성자.
    - 컴파일러가 자동으로 만들어주기도 함.
    
    ```cpp
    Person p;   // 기본 생성자 호출
    
    ```
    
2. **매개변수 있는 생성자 (Parameterized Constructor)**
    - 값을 전달받아 객체를 원하는 값으로 초기화.
    
    ```cpp
    Person p("Alice", 20);
    
    ```
    
3. **복사 생성자 (Copy Constructor)**
    - 다른 객체를 복사해서 새로운 객체 생성.
    
    ```cpp
    Person p1("Bob", 25);
    Person p2 = p1;  // 복사 생성자 호출
    
    임시객체위에 밥이랑 25가 올라가고, person p2 가 생기고 복사돼서 값이 copy paste된대..
    ```
    
4. **이동 생성자 (Move Constructor, C++11~)**
    - 임시 객체 자원을 “이동”시켜 효율적으로 초기화.
    
    ```cpp
    Person p3 = std::move(p1);
    
    => 보충하겠습ㄴ디ㅏ.,,
    ```
    

---

### 2-4. 생성자와 일반 함수 비교

| 구분 | **생성자(Constructor)** | **일반 함수(Function)** |
| --- | --- | --- |
| **이름** | 클래스 이름과 동일해야 함 | 임의의 이름 가능 |
| **반환 타입** | 없음 (심지어 `void`도 아님) | 원하는 반환 타입 가질 수 있음 |
| **호출 시점** | 객체가 **생성될 때 자동 호출** | 프로그래머가 직접 호출해야 함 |
| **역할** | 객체 초기화 (멤버 변수 설정, 준비 작업) | 특정 기능 수행 (연산, 처리 등) |
| **자동 생성 여부** | 사용자가 안 만들면 컴파일러가 기본 생성자 제공 | 자동 생성 없음 (직접 작성해야 함) |
| **오버로딩 가능성** | 가능 (매개변수 다르게 여러 개 선언 가능) | 가능 (매개변수 다르게 여러 개 선언 가능) |
| **특수한 종류** | 기본 생성자, 매개변수 생성자, 복사 생성자, 이동 생성자 | 일반 함수는 그런 특별한 구분 없음 |
| **소멸과의 관계** | 생성자는 객체 "탄생"에만 관여 | 일반 함수는 객체 수명과 직접 관계 없음 |

---

### 2-5. 예시 코드

```cpp
#include <iostream>
#include <string>

class Person {
public:
    // 생성자들
    Person() : name("Unknown"), age(0) {}   // 기본 생성자
    Person(std::string n, int a) : name(n), age(a) {} // 매개변수 생성자

    // 일반 함수
    void introduce() {
        std::cout << "Hi, I'm " << name << " and I'm " << age << " years old.\n";
    }

private:
    std::string name;
    int age;
};

int main() {
    Person p1;              // 기본 생성자 자동 호출
    Person p2("Alice", 20); // 매개변수 생성자 자동 호출

    p1.introduce(); // 일반 함수는 직접 호출해야 실행됨
    p2.introduce();
}

```

---

## 3. 초기화와 대입의 차이점

### 3-1. 문제 상황: “대입만 하고 있다”

```cpp
class ABEntry {
public:
    ABEntry(const std::string& name,
            const std::string& address,
            const std::list<PhoneNumber>& phones);
private:
    std::string theName;
    std::string theAddress;
    std::list<PhoneNumber> thePhones;
    int numTimesConsulted;
};

ABEntry::ABEntry(const std::string& name,
                 const std::string& address,
                 const std::list<PhoneNumber>& phones)
{
    theName = name;       // 대입
    theAddress = address; // 대입
    thePhones = phones;   // 대입
    numTimesConsulted = 0;// 대입
}

```

- `ABEntry` 객체가 만들어질 때, `theName`, `theAddress`, `thePhones`는 **기본 생성자**로 이미 초기화됨.
- 생성자 본문에 들어오면, 이미 초기화된 값에 다시 **대입 연산자**가 호출됨.
- `std::string` 같은 객체는 **기본 생성자 + 대입보다 복사 생성자 하나가 더 효율적임**.

---

### 3-2. 해결 방법: 멤버 초기화 리스트로 해결!

```cpp
ABEntry::ABEntry(const std::string& name,
                 const std::string& address,
                 const std::list<PhoneNumber>& phones)
: theName(name),
  theAddress(address),
  thePhones(phones),
  numTimesConsulted(0)
{}

```

- `theName`, `theAddress`, `thePhones` → **복사 생성자로 바로 초기화**
- `numTimesConsulted` → 0으로 직접 초기화
- 효율적 + 안전

---

### 3-3. 기본 제공 타입 초기화

```cpp
ABEntry::ABEntry()
: theName(),
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{}

```

- `int`, `double` 등 기본 타입도 초기화 리스트에 넣는 습관이 좋음
- 실수로 초기화를 빼먹을 경우 방지

---

### 3-4. 핵심 포인트

1. 대입(=)은 초기화가 아님
2. 멤버 초기화 리스트 사용 → 진짜 초기화
3. 효율성: 객체 타입 → 복사 생성자 한 번
4. 안전성: 기본 타입도 반드시 초기화

---

### 3-5. 쉽게 풀어쓰기

- 지금 코드: 태어날 때 이름 없이 → 바로 덮어쓰기
- 좋은 코드: 태어날 때부터 이름 지정

👉 **“생성자 본문에서 대입하지 말고, 멤버 초기화 리스트로 반드시 초기화하라.”**

---

## 4. 객체 초기화 순서

- 기본 클래스 → 파생 클래스 순서
- 데이터 멤버 → 선언된 순서대로 초기화
- 초기화 리스트 순서도 **선언 순서와 동일하게 맞추는 것이 좋음**

---

## 5. 정적 객체 초기화 문제

### 5-1. 정적 객체 종류

1. 전역 객체 (global object)
2. 네임스페이스 범위 객체
3. 클래스 내부 `static` 객체
4. 함수 내부 `static` 객체 (**지역 정적 객체**)
5. 파일 범위 `static` 객체
- 지역 정적 객체: 함수 안 정의
- 비지역 정적 객체: 나머지

---

### 5-2. 문제

- 서로 다른 번역 단위에 있는 **비지역 정적 객체 초기화 순서 정의되지 않음**
- 예시:

```cpp
class FileSystem {
public:
    std::size_t numDisks() const;
};

extern FileSystem tfs; // 비지역 정적 객체 (전역)

class Directory {
public:
    Directory(params);
};

Directory::Directory(params)
: disks(tfs.numDisks()) // tfs 사용
{}

Directory tempDir(params); // 비지역 정적 객체

```

- `tempDir`이 초기화될 때 `tfs`가 초기화되지 않으면 undefined behavior 발생

---

### 5-3. 해결: 지역 정적 객체 + 참조 반환

```cpp
FileSystem& tfs() {
    static FileSystem fs; // 지역 정적 객체
    return fs;
}

Directory& tempDir() {
    static Directory td;
    return td;
}

```

- 함수 최초 호출 시 초기화 → 초기화 순서 보장
- 사용자는 그대로 `tfs().numDisks()` 사용 가능

---

### 5-4. 주의점

- C++11 이후: 지역 정적 객체 초기화 **스레드 안전**
- C++03 이전: 멀티스레드 환경에서 동기화 필요
- 시작 단계에서 참조 반환 함수 미리 호출 가능

---

### 5-5. 정리

1. 비지역 정적 객체 초기화 순서 **정의되지 않음** → 위험
2. 해결: **지역 정적 객체 + 참조 반환 함수**
3. 장점: 초기화 순서 문제 해결, 사용하지 않으면 비용 없음
4. 주의: 멀티스레드 환경 고려

---