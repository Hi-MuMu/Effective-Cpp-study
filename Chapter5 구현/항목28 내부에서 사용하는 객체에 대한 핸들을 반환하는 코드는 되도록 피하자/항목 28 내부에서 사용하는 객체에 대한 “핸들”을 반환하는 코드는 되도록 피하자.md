# 항목 28: 내부에서 사용하는 객체에 대한 “핸들”을 반환하는 코드는 되도록 피하자 - 작성자: 고형주

<aside>
🔎

# 이것만은 잊지말자!

- 어떤 객체의 내부요소에 대한 핸들(참조자, 포인터, 반복자)을 반환하는 것은 되도록 피하세요. 캡슐화 정도를 높이고, 상수 멤버 함수가 객체의 상수성을 유지한 채로 동작할 수 있도록 하며, 무효참조 핸들이 생기는 경우를 최소화할 수 있습니다.
</aside>

## 핵심 용어

<aside>

### 핸들 (Handle)

의미: 다른 객체에 손을 댈 수 있게 하는 매개자
종류: 참조자(reference), 포인터(pointer), 반복자(iterator)
위험성: 내부 데이터에 직접 접근할 수 있게 하여 캡슐화를 무너뜨림

### 무효참조 핸들 (Dangling Handle)

의미: 핸들이 가리키는 객체가 이미 소멸되어 유효하지 않은 상태
발생 시점: 임시 객체가 소멸된 후에도 그 내부 요소를 가리키는 핸들이 남아있을 때
결과: 미정의 동작, 프로그램 크래시 가능성

</aside>

 

---

<aside>

# 📌 객체에서의 핸들 사용

</aside>

## 예) 사각형을 사용하는 응용 프로그램

**목표**: 사각형을 추상화한 `Rectangle` 클래스의 객체를 썼을 때의 메모리 부담을 최대한 줄이기.

**개선 시도**: 사각형의 영역을 정의하는 꼭짓점을 `Rectangle` 자체에 넣는 것이 아니라, 꼭짓점들을 별도의 구조체에 넣은 후에 `Rectangle`이 이 구조체를 가리키도록 구현

```cpp
class Point {
public:
	Point(int x, int y);
	...
	void setX(int newVal);
	void setY(int newVal);
	...
};

struct RectData {  // Rectangle에 쓰기 위한 점 데이터
	Point ulhc;  // ulhc = "좌측 상단(upper left-hand corner)" 
	Point lrhc;  // lrhc = "우측 하단(lower right-hand corner)" 
};

class Rectangle {
	public:
		// 사용자 정의 타입을 전달할 때는
		// 값에 의한 전달보다 참조에 의한 전달방식을 쓰는 것이 효율적이므로 참조자로 반환
		// 그래서 (스마트) 포인터로 참조하는 Point 객체에 대한 참조자를 반환하는 형태로 만들어짐
		Point& upperleft() const { return pData->ulhc; }
		Point& lowerRight() const { return pData->lrhc; }
		
	private:
		std::tr1::shared_ptr<RectData> pData;
}
```

`Rectangle` 클래스의 사용자는 영역 정보를 알아내어 쓸 때가 생길 것이므로, `Rectangle` 클래스에는 `upperLeft` 및 `lowerRight` 함수가 멤버 함수로 들어 있다. 

## ❌ 문제 **1 - 상수성 파괴**

컴파일은 되지만 `upperLeft` 함수와 `lowerRight` 함수가 상수(`const`) 멤버 함수이므로 옳지 않다.

`Rectangle`의 꼭짓점 정보를 알아낼 수 있는 방법만 사용자에게 제공하고 `Rectangle` 객체를 수정하는 일은 할 수 없도록 설계되었는데, 이 함수들이 반환하는 것은 `private` 멤버인 내부 데이터에 대한 참조자이다. 

그러므로 호출부에서 이 참조자를 써서 내부 데이터를 마음대로 수정할 수 있다는 위험이 생긴다.

```cpp
Point coord1(0, 0);
Point coord2(100, 100);

// rec은 (0, 0)부터 (100, 100)의 영역에 있는 상수 Rectangle의 객체입니다.
const Rectangle rec(coord1, coord2);  // <!> const 객체로 선언

// 이제 이 rec은 (50, 0)부터 (100, 100)의 영역에 있게 됩니다.
rec.upperLeft().setX(50);  // <!> const 객체인데 내부 데이터 수정 가능
```

위와 같이 사용하면 `upperLeft`를 호출한 쪽은 `rec`의 숨겨진 `Point` 데이터 멤버를 참조자로 가져와 변경할 수 있게 된다. 하지만 `rec`은 상수 객체로 선언된 것이므로 의도된 동작이 아니다.

## ❌ 문제 **2 - 캡슐화 파괴**

```cpp
class Rectangle {
	public:
		// ulhc와 lrhc는 private 멤버이지만, 실질적으로는 public 멤버와 동일하다.
    // public 함수를 통해 직접 접근이 가능하기 때문이다.
		Point& upperleft() const { return pData->ulhc; }
		Point& lowerRight() const { return pData->lrhc; }
		
	private:
		std::tr1::shared_ptr<RectData> pData;
}
```

## 정리

### 1️⃣ 클래스 데이터 멤버는 숨겨도 그 멤버의 참조자를 반환하는 함수들의 최대 접근도에 따라 캡슐화 정도가 정해진다.

<aside>

클래스 데이터 멤버의 실질적 접근 수준 = 그 멤버의 핸들을 반환하는 함수들의 최대 접근 수준

</aside>

`ulhc`와 `lrhc`는 `private`으로 선언되어 있지만, 실질적으로는 `public` 멤버이다. 이들의 참조자를 반환하는 `upperLeft` 및 `lowerRight` 함수가 `public` 멤버 함수이기 때문이다. 

### 2️⃣ 어떤 객체에서 호출한 상수 멤버 함수의 참조자 반환 값의 실제 데이터가 그 객체의 바깥에 저장되어 있다면, 이 함수의 호출부에서 그 데이터의 수정이 가능하다.

(항목 3의 비트수준 상수성 내용 참고)

---

<aside>

# 📌 [참고] 핸들 반환의 위험성

</aside>

멤버 함수가 참조자를 반환하는 것이 아니라, 포인터나 반복자를 반환하도록 되어 있었다고 해도 **같은 이유로 인해 같은 문제**가 생긴다. 

## 모든 핸들 종류가 위험함

```cpp
// 모두 동일한 위험성을 가짐
Point& getPoint();           // 참조자
Point* getPointPtr();        // 포인터  
vector<Point>::iterator getIter();  // 반복자
```

참조자, 포인터 및 반복자는 모두 핸들(handle, 다른 객체에 손을 댈 수 있게 하는 매개자)이고, 어떤 객체의 내부 요소에 대한 핸들을 반환하게 만들면 언제든지 그 객체의 캡슐화를 무너뜨리는 위험을 감수할 수 밖에 없다.

```cpp
const Point& getPoint() const;  // const 함수에서 const 참조자 반환해도 위험
```

핸들 반환 때문에 상수 멤버 함수마저도 객체 상태의 변경을 허용하는 상황이 생길 수 있다.

어떤 객체의 “내부 요소(internals)”라고 하면 데이터 멤버만 생각할 수도 있지만, 일반적인 수단으로 접근이 불가능한(protected, private) 멤버 함수도 객체의 내부 요소에 들어가므로 이들에 대한 핸들도 반환하지 말아야 한다. **외부 공개가 차단된 멤버 함수에 대해, 이들의 포인터를 반환하는 멤버 함수를 만드는 일은 없어야 한다.**

핸들 반환 함수가 하나라도 들어가는 순간부터 실질적인 접근 수준이 바뀐다. 멤버 함수 포인터를 반환하는 함수의 접근도에 맞춰지는 것이다. **`protected`이나 `private` 멤버로 선언된 함수라고 해도 사용자 측면에서는 얼마든지 이들의 포인터를 얻어내어 호출 가능**하기 때문이다. 

하지만 멤버 함수의 포인터를 반환하는 함수는 흔하지 않다.

---

<aside>

# 📌 해결 방법

</aside>

멤버 함수가 가진 문제는 반환 타입에 `const` 키워드만 붙이면 해결된다. 이를 통해 사용자는 사각형을 정의하는 꼭짓점 쌍을 읽을 수는 있지만 쓸 수는 없게 된다.

```cpp
class Rectangle {
	public:
    // const 참조자로 반환하여 읽기 전용 접근만 허용
    const Point& upperLeft() const { return pData->ulhc; }
    const Point& lowerRight() const { return pData->lrhc; }
    
	private:
    std::tr1::shared_ptr<RectData> pData;
};
```

`upperLeft`와 `lowerRight`에 `const`를 붙여 선언했으니 호출부에서 객체의 상태를 바꾸지 못하도록 컴파일러 수준에서 막게 된다.

### ✅ 개선

- **상수성 보장**: `const` 객체의 상태를 변경할 수 없음
    - 읽기 접근만 주어지고 쓰기 접근은 여전히 금지
- **의도적 캡슐화 완화**: 읽기 접근만 허용하여 제한적으로 내부 데이터 공개
    - 사용자들이 `Rectangle`을 구성하는 `Point`를 읽을 수 있는 것은 설계 단계에서 허용된 행동이므로 의도적인 캡슐화 완화이다.

### ⚠️ 남은 문제

- **무효참조 핸들**

`upperLeft` 함수와 `lowerRight` 함수를 보면 내부 데이터에 대한 핸들을 반환하고 있는 부분이 남아 있다. 이를 남겨두면 다른 쪽에서 문제가 될 수 있다. 가장 큰 문제는 **무효참조 핸들(dangling handle)**로서, 핸들이 있지만 그 핸들을 따라갔을 때 실제 객체의 데이터가 없는 문제이다. 핸들이 참조하고 있는 객체가 갑자기 사라지는 상황은 함수가 객체를 값으로 반환할 경우에 흔하게 발생한다. 

예를 들어 다음과 같이 어떤 GUI 객체의 사각 테두리 영역(bounding box)을 `Rectangle` 객체로 반환하는 함수가 있다고 가정하자. 이 상태에서 어떤 사용자가 이 함수를 사용한다고 가정하자.

```cpp
class GUIObject { ... };

// Rectangle 객체를 값으로 반환합니다. 반환 타입에 const가 붙은 이유는 항목 3 참고
const Rectangle boundingBox(const GUIObject& obj)
	
// pgo를 써서 임의의 GUIObject를 가리키도록 합니다.
GUIObject *pgo;
...

// pgo가 가리키는 GUIObject의 사각 테두리 영역으로부터 좌측 상단 꼭짓점의 포인터를 얻습니다.
// ❌ 위험한 코드
const Point *pUpperLeft = &(boundingBox(*pgo).upperLeft());
```

### 문제 과정

1. `boundingBox(*pgo)` 호출 → 임시 `Rectangle` 객체 생성 (이름은 일단 `temp`로 명명)
2. `temp`에 대해 `upperleft`가 호출 (`temp.upperLeft()`) → `temp`의 내부 데이터인 `Point` 참조자 반환
3. `&` 연산자로 주소를 획득하고 `pUpperLeft` 포인터에 대입
4. 문장이 끝나면 `boundingBox` 함수의 반환 값(임시 객체인 `temp`)이 소멸 → 
    
    `temp` 소멸로 인해 `Point` 객체들도 사라짐
    
5. `pUpperLeft`는 이미 소멸된 객체(무효한 주소)를 가리키게 됨

**`pUpperLeft`에게 객체를 달아줬다가 주소 값만 남기고 다 사라지게 된다.**

그러므로 **객체의 내부에 대한 핸들을 반환하는 함수는 핸들의 종류에 상관없이 위험**하다. 핸들을 반환하는 함수로 인해 일단 바깥으로 떨어져나간 핸들은 핸들이 참조하는 객체보다 더 오래 살 위험이 있기 때문이다.

---

<aside>

# 📌 핸들 반환이 허용되는 상황

</aside>

핸들을 반환하는 멤버 함수를 피하는 것이 권장되지만 필요할 때도 있다.

## 예외 상황

```cpp
// 1. 표준 컨테이너의 operator[]
std::vector<int> vec = {1, 2, 3};
int& element = vec[0];  // 내부 요소에 대한 참조자 반환

// 2. string의 operator[]
std::string str = "hello";
char& ch = str[0];      // 내부 문자에 대한 참조자 반환
```

예를 들어 `operator[]` 연산자는 `string`이나 `vector` 등의 클래스에서 각각의 원소를 참조할 수 있게 만드는 용도로 제공되고 있는데, 실제로 이 연산자는 내부적으로 해당 컨테이너에 들어 있는 각각의 원소 데이터에 대한 참조자를 반환하는 식으로 동작한다. (항목 3 참조).

- **설계 의도**: 컨테이너의 요소에 직접 접근
- **생명 주기 관리 가능**: 원소 데이터는 컨테이너가 사라질 때 같이 사라지는 데이터이므로 사용자가 컨테이너와 요소의 생명주기를 인지할 수 있음

**어디까지나 예외 상황이고 일반적인 상황은 아니다.**

---

<aside>

# 📌 결론

</aside>

## 이를 통해 지키는 원칙

- **캡슐화 보호**: 내부 데이터에 대한 직접 접근 차단
- **상수성 유지**: const 멤버 함수가 실제로 객체 상태를 보호하도록 설계
- **생명주기 안전성**: 무효참조 핸들 발생 가능성 최소화

<aside>

**핸들을 반환하는 함수는 그 핸들이 참조하는 객체보다 더 오래 살 위험이 있다.**

**안전성을 위해 핸들을 반환하는 함수는 가능한 피하고, 꼭 필요할 때만 사용하자.**

</aside>

---