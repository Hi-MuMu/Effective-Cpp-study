# 항목 31: 파일 사이의 컴파일 의존성을 최대로 줄이자 - 작성자: 한지윤

<aside>

# 🔎 이것만은 잊지말자!

- 컴파일 의존성을 최소화하는 작업의 배경이 되는 가장 기본적인 아이디어는 
**‘정의’** 대신에 **‘선언’**에 의존하게 만들자는 것입니다. 
이 아이디어에 기반한 두 가지 접근 방법은 **핸들 클래스**와 **인터페이스 클래스**입니다.
- **라이브러리 헤더는 그 자체로 모든 것**을 갖추어야 하며 **선언부만 갖고 있는 형태**여야 합니다. 이 규칙은 템플릿이 쓰이거나 쓰이지 않거나 동일하게 적용합시다.
</aside>

---

# 📌 문제의식과 개념 정리

> **🚨 핵심 문제**
> 
> 
> 클래스 정의에 **구현 세부사항**이 포함되면 **불필요한 컴파일 의존성**이 생긴다!
> 

## 🟩 일반적인 클래스 정의

```cpp
class Person {
  Person(const std::string&, const Date&, const Address&);
  ...
private:
  std::string theName;
  Date theBirthDate;
  Address theAddress;
};
```

### **🚧 여기서 문제점은….**

- `Date`, `Address`, `std::string` 이 구현 세부사항
- 정의를 보려면 각각의 `.h`를 `#include` 해야겠죠??

```cpp
#include <string>
#include "date.h"
#include "address.h"
```

### 😩 결과

이 클래스가 정의된 파일은 항상 `string`, `date`, `address`를 다 끌고 다니게 되는거임

---

## 🟩 컴파일 의존성(Compliation Dependency)이란?

### 🧠 정의

> 한 파일이 다른 파일의 변경에 민감하게 반응해서
**작은 변화에도 재컴파일이 필요해지는 현상**
> 

### ☠️ 실제 문제 상황

- 세 헤더 중 하나만 바뀌어도? → `Person.h` 다시 컴파일 해야함
- `Person.h`를 사용하는 모든 파일도 전부 재컴파일

### 🚨 이런 상황이 반복된다면?

- 빌드 시간이 길어짐
- 불필요한 파일까지 다시 컴파일
- 팀 작업 시 충돌 증가

<aside>

C++ 클래스 정의에 **구현 세부사항**이 섞여 있기 때문에,
**의존성이 꼬리에 꼬리를 물고 확산**됨

</aside>

## 🟩 그럼 어떻게 해결함?

### 🥸 전방 선언을 아시나요?

```cpp
namespace std {
  class string;  // 근데 이건 틀린거래여 하지만 이런 느낌으로 해라~ 정도로 이해하면 됨
}

// 이게 전방선언
class Date;
class Address;
```

- 이런 식으로 헤더 포함 없이도 타입만 알려주면 됨
- 포인터/참조로 사용하면 정의까지 **필요 없음**
- 위에 코드가 왜 컴파일이 안될까….?
    
    <aside>
    
    **🚨 표준 라이브러리(std)의 타입은 사용자가 전방 선언해서 쓰면 안 됨**
    
    </aside>
    
    ### 🔎 전방 선언이 뭐길래
    
    ```cpp
    class MyClass;
    ```
    
    - 클래스 정의를 미리 알리지 않고 이름만 알려주는 것
    - 포인터/참조로 사용할 때 정의가 없어도 컴파일 가능
    - 빠른 컴파일, 낮은 의존성 가능
    
    ### 🔎 근데 `std::string`은?
    
    ```cpp
    std::string name;
    ```
    
    이렇게 객체를 직접 포함하면, **컴파일러**는 `string`의 **내부 구조(크기 등)**을 알아야 한대여
    
    → 그럼 정의가 필요한데…
    
    → 전방 선언만으로는 **절대 부족**하다고 함
    
    ### 🔎 결론
    
    ```cpp
    namespace std {
      class string;  // 이렇게 하면 안 됨
    }
    ```
    
    1. 표준 라이브러리의 타입은 사용자가 전방선언하면 안되고
    2. 컴파일러의 동작이 보장되지 않음 (구현마다 std::string의 내부 정의 방식이 다를 수도….)
    3. 추후 버전 호환성, 정의되지 않은 동작 → 전방 선언해도 의미가 다를 수 있어서 위험함
    
    > 전방 선언은 **우리가 만든 클래스나 구조체**에만 써라
    표준 라이브러리는 **헤더로 가져와** 쓰자~
    > 

---

# 📌 해결 전략과 실전 설계 패턴

## 🟩 왜 전방 선언만으로 부족할까?

### 문제점 1️⃣

> 클래스 객체를 **직접 멤버로 가질 경우**, 컴파일러는
**객체 크기를 알아야** 메모리를 할당할 수 있음
> 

```cpp
Person p;   // 컴파일러는 p의 크기를 알아야 함 → 정의 필요
```

### 문제점 2️⃣

> 전방 선언만 해놓고 객체를 만들면 컴파일 불가
**포인터로 사용해야 정의가 필요 없음**
> 

## 🟩 포인터를 활용한 해결책

```cpp
Person* p;  // 포인터 크기는 고정됨 → Person 정의 없어도 컴파일 가능
```

- 포인터 크기는 고정이라 `Person` 클래스의 정의를 몰라도 컴파일 가능
- 즉, **포인터 사용이 컴파일 의존성을 줄이는 핵심 수단**

## 🟩 pImpl 관용구(Pointer to Implementation)

### 🛸 핵심

> 클래스 정의를 인터페이스(`.h`)와 구현(`.cpp`)으로 완전히 분리
> 

```cpp
// 헤더 파일
#include <string>

// 전방 선언
class PersonImpl;

class Person {
public:
	// 코드들~
private:
  std::shared_ptr<PersonImpl> pImpl;  // 구현을 숨김
};
```

- `pImpl`은 `private`멤버로 존재함 → 사용자에게 구현 노출 X

### 🚀 `pImpl` 패턴의 이점

| 기존 구조 | PImpl 구조 |
| --- | --- |
| 구현 세부사항 노출 | 구현 완전 은닉 |
| 헤더 변경 시 전부 재컴파일 | 구현만 바뀌면 헤더 영향 없음 |
| 컴파일 의존성 높음 | 컴파일 의존성 낮음 |
| 사용자 코드도 간접적으로 영향 받음 | 사용자 코드 변화 없음 |

### 🧠  정의가 아닌 선언에 의존하자

### 개념 정리

> dependencies on definitions ❌
> 
> 
> **→ dependencies on declarations ✅**
> 
- 헤더 파일은 **자체적으로 의미**를 가져야 함 (`self-sufficient`)
- 정의가 필요한 경우는 `.cpp`에서만 참조
- 사용자 측은 선언만 보고도 문제없이 사용 가능해야 함

> 인터페이스는 최대한 가볍고, 구현은 철저히 감추자!
> 

---

# 📌 고급 기법과 실전 설계 지침

## 🟩 전방 선언의 실제 기준

### 1️⃣ 객체를 직접 포함할 때

```cpp
class Date;

Date d;              // ❌ 직접 객체 → 정의 필요
Date d = today();    // ❌ 객체 반환 → 정의 필요
```

- `Data d`
    - 컴파일러는 `Date`가 몇 바이트인지 알아야 메모리 공간을 잡을 수 있음
    - 그래서 **정의가 있어야 함**

### 2️⃣ 객체를 참조 또는 포인터로 쓸 때

```cpp
class Date;

Date* d; // 포인터
Date& d; // 참조
```

→ `Date`의 선언만 있으면 됨 (전방 선언 ㄱㅊ)

- 컴파일러가 Data의 실제 내용을 알 필요가 없음
- 컴파일러는 아 이런 타입이 있구나~정도만 알아도 ㄱㅊ

## 🟩 클래스 선언만으로도 함수 선언 가능

```cpp
class Date;  // 전방 선언

Date today();                         // 정의 없이 선언 가능
void clearAppointments(Date d);       // 값 전달도 OK
```

> 호출자가 `Date` 정의를 갖고 있으면 되므로
**라이브러리 설계 시 헤더 의존성 확 줄일 수 있음**
> 

## 🟩 선언부와 정의부 헤더 분리 전략

### 🥸 왜 분리해야 하나요?

- 호출이 발생하는 쪽은 정의가 필요함
- **호출이 일어나지 않는 쪽**은 **선언만으로 충분**
- 라이브러리 사용자는 정의가 없어도 선언만 보고 컴파일 가능해야 효율적

<aside>

**예시**

```cpp
// datefwd.h
class Date;
Date today();
void clearAppointments(Date d);
```

- Date 정의는 없고, 전방 선언만 존재
- 진짜 정의는 data.h에 있겠지요
</aside>

### ✅ 실제 라이브러리도 이렇게 한다

- C++ 표준 라이브러리도 `<iosfwd>`를 통해 전방 선언만 제공함
- `<iostream>`, `<sstream>`, `<fstream>` 등은 정의 포함됨

> 많은 빌드 환경에서 **템플릿 정의까지 헤더에 넣지 않음**
> 
> 
> → 선언만 먼저 분리해 관리하는 방식이 표준임
> 

## 🟩 핸들 클래스 (Handle Class)로서의 PImpl

- `Person`은 외부에 공개된 클래스
- 내부 구현은 `PersonImpl`로 분리

```cpp
#include "Person.h"       // Person 클래스니까 정의해야함
#include "PersonImpl.h"   // 이거호출안하면 멤버함수 호출 못함

class Person {
  std::shared_ptr<PersonImpl> pImpl;
};
```

→ **핸들(외부에서 보는 클래스)**

→ **구현은 숨김(내부 구현자)**

```cpp
// Person.cpp
Person::Person(...) : pImpl(new PersonImpl(...)) {}

std::string Person::name() const {
  return pImpl->name();  // 실제 일은 PersonImpl이 함
}
```

- 외부 사용자는 `Person`만 알면 되고
- 내부 구현은 완전히 감춰짐
- 인터페이스와 구현 완전 분리
- 핸들클래스
    
    ```cpp
    // 사용자에게 보이는 클래스 (핸들)
    class Person {
    public:
        Person(const std::string& name, const Date& birth, const Address& addr);
        std::string name() const;
    private:
        std::shared_ptr<class PersonImpl> pImpl; // 구현 숨김
    };
    
    // 실제 구현
    class PersonImpl {
    public:
        std::string name() const { return theName; }
    private:
        std::string theName;
    };
    ```
    
    ### ✅ 실제 동작 흐름
    
    1. `Person` 객체 생성
        
        ```cpp
        Person p("홍길동", birth, addr);
        
        ```
        
        → 생성자에서 내부적으로 `pImpl = new PersonImpl("홍길동", birth, addr)` 실행됨
        
    2. `Person::name()` 호출
        
        ```cpp
        std::cout << p.name();
        
        ```
        
        → 사실은 `pImpl->name()`을 대신 호출
        
    3. 사용자가 `PersonImpl`의 존재를 전혀 몰라도 됨
        
        → 즉, **구현은 숨겨지고 인터페이스만 보임**
        

## 🟩 인터페이스 클래스(Interface Class)

> 데이터 멤버 없이
**순수 가상 함수(pure virtual functions)** 만 가진 클래스
> 

```cpp
class Person {
public:
  virtual ~Person();
  virtual std::string name() const = 0;
  virtual std::string birthDate() const = 0;
  virtual std::string address() const = 0;
};
```

- 상속을 통해 다양한 구현 제공 가능
- 호출자는 인터페이스만 의존
- 구현이 바뀌어도 호출자 쪽은 재컴파일 필요 없음
- 오직 “무슨 기능을 제공한다”라는 약속만 정의

### 🔎 예제

```cpp
class RealPerson : public Person {
public:
  RealPerson(const std::string& name, const Date& birthday, const Address& addr);
  virtual std::string name() const;
  virtual std::string birthDate() const;
  virtual std::string address() const;
private:
  std::string theName;
  Date theBirthDate;
  Address theAddress;
};
```

객체 생성은 **팩토리 함수** 사용

```cpp
std::shared_ptr<Person> Person::create(...);
```

사용자는

```cpp
std::shared_ptr<Person> p = Person::create(name, birth, addr);
std::cout << p->name();
```

구현 클래스(RealPerson)을 몰라도 사용 가능

## 🟩 핸들 클래스 vs 인터페이스 클래스

| 구분 | 핸들 클래스 | 인터페이스 클래스 |
| --- | --- | --- |
| 구현 숨기기 방식 | PImpl(포인터 멤버로 구현 감춤) | 순수 가상 함수로 인터페이스만 제공 |
| 장점 | 기존 코드와 호환성 높음 | 다형성 지원, 유연한 구조 |
| 단점 | 포인터 접근 오버헤드 | 호출마다 가상 함수 테이블 비용 |
| 공통점 | 둘 다 **인터페이스와 구현을 분리**하여 컴파일 의존성 최소화 |  |

# 📌 결론

<aside>

- **핵심 원칙**
    - 정의가 아닌 선언에 의존하라
    - 인터페이스와 구현을 철저히 분리하라
- **핸들 클래스 & 인터페이스 클래스**
    - 구현이 바뀌어도 사용자에게 영향 최소화
    - 유지보수성 ↑, 빌드 속도 ↑
- **주의점**
    - 실행 속도와 메모리 크기에서 일부 손해 감수
    - 하지만 제품 개발에서는 “빠른 빌드와 낮은 결합도”가 훨씬 중요
</aside>