# 항목 43: 템플릿으로 만들어진 기본 클래스 안의 이름에 접근하는 방법을 알아 두자 - 작성자: 한지윤

<aside>
🔎

# 이것만은 잊지말자!

- 파생 클래스 템플릿에서 기본 클래스의 이름을 참조할 때는, `this→` 를 접두사로 붙이거나 기본 클래스 한정문을 명시적으로 써 주는 것으로 해결합시다.
</aside>

---

# 📌 1. 문제 상황

- 여러 회사(CompanyA, CompanyB …)에 메시지를 전송하는 프로그램 작성
- 메시지 전송 방식: **암호화 / 평문**
- 공통 인터페이스를 `MsgSender` 템플릿으로 정의

```cpp
template<typename Company>
class MsgSender {
public:
    void sendClear(const MsgInfo& info) {
        std::string msg;
        // info 로부터 msg 생성
        Company c;
        c.sendCleartext(msg);   // 회사 클래스에 따라 달라짐
    }
};
```

---

# 📌 2. 파생 클래스에서의 문제

- 메시지 전송 전/후에 **로그 기록**을 추가하고 싶음
- 그래서 파생 클래스 `LoggingMsgSender` 작성

```cpp
template<typename Company>
class LoggingMsgSender : public MsgSender<Company> {
public:
    void sendClearMsg(const MsgInfo& info) {
        // 로그 기록
        sendClear(info);  // ⚠️ 컴파일 에러 가능!
    }
};
```

### ⚠️ 문제

- `sendClear` 함수가 **기본 클래스에 항상 존재한다는 보장이 없음**
- 특정 회사 클래스(예: CompanyZ)는 `sendCleartext`만 있고, `sendClear` 자체를 지원하지 않을 수도 있음
- 이때 템플릿 특수화로 `MsgSender<CompanyZ>` 버전이 만들어지면 → 파생 클래스에서 `sendClear` 호출이 모호해져 **컴파일 에러 발생**

---

# 📌 3. 원인

- C++ 컴파일러는 **이른 진단(Early Diagnose)**을 하기 때문
- 템플릿 인스턴스화 시점에, 파생 클래스가 기본 클래스 멤버 함수에 안전하게 접근할 수 있는지 판단해야 함
- 기본 클래스 템플릿이 특수화될 경우, 파생 클래스에서 호출하는 멤버 함수가 존재하지 않을 수도 있으므로 문제가 발생

---

## 4. 해결 방법 (3가지)

템플릿 기반 기본 클래스의 멤버 함수에 접근할 때는 다음 방법 중 하나를 사용해야 한다.

### (1) `this->` 사용

```cpp
this->sendClear(info);   // sendClear가 상속된 것으로 간주
```

### (2) `using` 선언

```cpp
using MsgSender<Company>::sendClear;
sendClear(info);
```

### (3) 명시적 한정자(::) 사용

```cpp
MsgSender<Company>::sendClear(info);
```

---

## 5. 핵심 교훈

- 파생 클래스 템플릿에서 기본 클래스 템플릿의 이름을 사용할 때는 **무조건 주의 필요**
- **“this->”를 붙이거나, using 선언, 명시적 한정자(::)** 를 사용해 접근해야 안전하다.