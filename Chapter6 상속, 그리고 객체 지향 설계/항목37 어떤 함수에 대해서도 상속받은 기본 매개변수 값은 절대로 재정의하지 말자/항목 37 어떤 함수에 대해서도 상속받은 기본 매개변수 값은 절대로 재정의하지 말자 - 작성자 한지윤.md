# 항목 37: 어떤 함수에 대해서도 상속받은 기본 매개변수 값은 절대로 재정의하지 말자 - 작성자: 한지윤

<aside>
🔎

# 이것만은 잊지말자!

- 상속받은 기본 매개변수 값은 절대로 재정의해서는 안됩니다.
왜냐하면 기본 매개변수 값은 정적으로 바인딩되는 반면, 가상 함수(여러분이 오버라이드 할 수 있는 유일한 함수죠)는 동적으로 바인딩되기 때문입니다.
</aside>

---

- C++에서 함수를 상속 받는 경우는 가상, 비 가상 함수
    - 36장에서 비가상함수는 재정의 하지 말자고 했으니 이번 장은 ‘기본 매개변수 값을 가진 가상 함수를 상속하는 경우'에 대한 이야기
- 37장의 제목의 이유는 **가상 함수는 dynamically(late) binding 되지만, 기본 매개변수 값은 static (early) binding이 되기 때문**
- C++에서 상속되는 함수 → **가상 함수(virtual)**
- 가상 함수 호출은 **동적 바인딩**
    - 지연 바인딩(**late binding**) 이라고 불리기도 함
- 기본 매개변수 값은 **정적 바인딩**
    - 선행 바인딩(**early binding**) 이라고 불리기도 함
- 👉 서로 다른 바인딩 방식이 충돌할 수 있음

# 예제 코드

```cpp
class Shape {
public:
    enum ShapeColor { Red, Green, Blue };

    // 기본 매개변수 값 = Red
    virtual void draw(ShapeColor color = **Red**) const = 0;
};

class Rectangle : public Shape {
public:
    // 기본 매개변수 값 = Green (문제 발생!!)
    virtual void draw(ShapeColor color = **Green**) const;
};

class Circle : public Shape {
public:
    virtual void draw(ShapeColor color) const;
};
```

```cpp
Shape *ps; *//Static type = Shape**
Shape *pc = new Circle; *//Static type = Shape**
Shape *pr = new Rectangle; *//Static type = Shape**

pr->draw();  // ❓ Red일까 Green일까?
```

- **정적 타입(Shape*)** → 기본 매개변수 값은 `Red`
- **동적 타입(Rectangle*)** → 실제 동작은 Rectangle의 `draw()`
- 결과: **기본 매개변수 값은 Red, 함수 동작은 Rectangle**
- Static Type
    - 소스에 선언해 놓은 선언문을 통해 갖게 되는 타입
    - ps, pc, pr 모두 Shape*이지만 진짜로 가리키는 type은 없다.
- Dynamic Type
    - 객체가 진짜로 가리키는 것이 무엇이냐에 따라 결정이 됨 (RTTI)
    - 이 객체가 어떻게 동작 할 것이냐
    - pc는 circle, pr은 rectangle, ps는 없음
    - 다음과 같이 하면 ps가 객체를 가지게 됨
    `ps = pc;` 
    `ps = pr;`
- `pr->draw();`
    - draw함수는 Rectangle의 있는 함수를 호출 할 것임 → 실질적으로 rectangle이기 때문
    - 하지만 default argument는 정적으로 선언이 된 shape에서 가지고 오게 됨.
    - 이는 pointer의 문제는 아님. Reference로 받아도 동일하게 발생함
    - → 이런 방식을 고집하는 이유는 compiler의 효율성 때문 (default arg를 제대로 가지고 오려면 관련 정보를 compiler가 알아야 함)
- 그렇다면 어떻게 짜야 할까?
    
    ```cpp
    class Shape{
    public:
        enum ShapeColor {Rec, Green, Blue};
        
        //Should be implemented in derived
        virtual void draw(ShapeColor color = Red) cosnt = 0;
        ...
    };
    
    class Rectangle: public Shape {
    public:
      virtual void draw(ShapeColor color = Red) const;
    };
    ```
    
    → 이러한 방식은 선호되지 않는다. 코드 중복, 그리고 default argument를 바꾸려면 모든 파생 클래스를 다 건드려야 한다.
    
    - Non-virtual interface idiom
        - 파생 클래스에서 재정의 할 수 있는 가상 함수를 private
        - 이 가상함수를 호출할 수 있는 비 가상함수를 Base class에
        
        ```cpp
        //NVI idiom
        class Shape{
        public:
            enum ShapeColor {Rec, Green, Blue};
          
            void draw(ShapeColor color = Red) cosnt {
              doDraw(color);
            }
            ...
        private:
          //Should be implemented in derived
          virtual void doDraw(ShapeColor color) const = 0;
        };
        
        class Rectangle: public Shape {
        public:
          ...
        private:
          virtual void doDraw(ShapeColor color) const;
        };
        ```