# 항목 34: 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자 - 작성자: 고형주

<aside>
🔎

# 이것만은 잊지말자!

- 인터페이스 상속은 구현 상속과 다릅니다. public 상속에서 파생 클래스는 항상 기본 클래스의 인터페이스를 모두 물려받습니다.
- 순수 가상 함수는 인터페이스 상속만을 허용합니다.
- 단순(비순수) 가상 함수는 인터페이스 상속과 더불어 기본 구현의 상속도 가능하도록 지정합니다.
- 비가상 함수는 인터페이스 상속과 더불어 필수 구현의 상속도 가하도록 지정합니다.
</aside>

 

---

<aside>

# 📌 상속의 두 가지 측면

</aside>

C++에서 함수 상속은 두 가지로 나뉜다.

1. **함수 인터페이스의 상속** - "이런 함수가 있어야 한다"
2. **함수 구현의 상속** - "이렇게 동작해야 한다"

클래스 설계자 입장에서 다음과 같은 선택지가 있다.

1. 멤버 함수의 **인터페이스(선언)만**을 파생 클래스에 상속시키고 싶을 때
2. **인터페이스 + 구현**을 모두 상속시키되, **오버라이드 가능**하게 하고 싶을 때
3. **인터페이스 + 구현**을 상속시키되, **오버라이드 불가능**하게 막고 싶을 때

## 예제: Shape 클래스 계층

그래픽 응용 프로그램의 기하학적 도형을 나타내는 클래스

```cpp
class Shape {
public:

	// 순수 가상 함수
	virtual void draw() const = 0;
	
	// 일반 가상 함수  
	virtual void error(const str::string& msg);
	
	// 비가상 함수
	int objectID() const;
	
	// ...
};

class Rectangle: public Shape { ... };
class Ellipse: public Shape { ... };
```

순수 가상 함수 `draw`가 있기 때문에 `Shape`는 추상 클래스이다. 그러므로 `Shape` 클래스의 인스턴스를 만들면 안되고, 이 클래스의 파생 클래스만 인스턴스화가 가능하다. 하지만 이 `Shape` 클래스가 이 클래스로부터 (`public` 상속에 의해) 파생된 클래스에 대해 미치는 영향은 절대적이다. 

### 이유

**멤버 함수 인터페이스는 항상 상속된다.** public 상속의 의미는 is-a 관계이므로, 기본 클래스에서 동작하는 함수는 파생 클래스에서도 반드시 동작해야 한다. 

### Shape 클래스에 선언된 3개의 함수

1. `draw` 함수는 암시적인 표시 장치에 현재의 객체를 그린다. 
    - 순수 가상 함수
2. `error` 함수는 다른 멤버 함수들이 호출하는 함수로, 이들이 에러를 보고할 필요가 있을 때 사용된다.
    - 단순 (비순수?) 가상 함수
3. `objectID` 함수는 주어진 객체에 붙는 유일한 정수 식별자를 반환한다. 
    - 비가상 함수

**선언이 다르므로 목적과 특징이 다르다.**

---

<aside>

# 📌 순수 가상 함수 (인터페이스만 상속)

</aside>

## **`draw` 함수**

```cpp
class Shape {
	public:
		virtual void draw() const = 0;
		...
};
```

## 특징

1. 어떤 순수 가상 함수를 물려 받은 **구체 파생 클래스가 해당 순수 가상 함수를 재선언해야 한다.**
2. 일반적으로 **추상 클래스 안에서 정의를 갖지 않는다.** (기본 구현을 갖지 않는다.)

## 목적

**파생 클래스에게 함수의 인터페이스만을 물려주는 것**

`Shape::draw`의 의미

- “모든 `Shape` 객체는 그리기가 가능해야 한다.”
- 하지만 `Shape` 차원에서는 구체적인 그리기 방법을 알 수 없다

## 사용 예제

```cpp
// [에러] Shape는 추상 클래스이다.
Shape *ps = new Shape;

// [정상]
Shape *ps1 = new Rectangle;
// Rectangle::draw를 호출합니다.
ps1->draw();

// [정상]
Shape *ps2 = new Ellipse;
// Ellipse::draw를 호출합니다.
ps2->draw();

// Shape::draw를 호출합니다.
ps1->Shape::draw();
// Shape::draw를 호출합니다.
ps2->Shape::draw();
```

**참고**: 순수 가상 함수도 구현을 가질 수 있지만, 이를 호출할 시 클래스 이름을 한정자로 붙여 명시해야 한다.

```cpp
// Shape::draw 호출 (구현이 있다면)
ps1->Shape::draw();  
```

---

<aside>

# 📌 단순 가상 함수 (인터페이스 + 기본 구현 상속)

</aside>

## **`Shape::error` 함수**

```cpp
class Shape {
public:
	virtual void error(const std::string& msg);
}
```

단순 가상 함수는 순수 가상 함수와 비교할 때 몇 가지 다른 면을 가지고 있다. 

파생 클래스로 하여금 함수의 인터페이스를 상속하게 한다는 점은 똑같지만, 파생 클래스 쪽에서 오버라이드할 수 있는 함수 구현부도 제공한다는 점이 다르다.

## 목적

**파생 클래스가 인터페이스뿐만 아니라 그 함수의 기본 구현도 물려받게 하는 것**

### `Shape::error`의 의미:

- "모든 클래스는 에러 처리 함수를 가져야 한다"
- "하지만 특별한 처리가 필요 없다면 기본 구현을 써도 된다"

## 위험성 설명: 항공기 예제

`XYZ`라는 이름의 가상의 항공사가 있고, 이 항공사의 비행기는 A 모델과 B 모델 밖에 없다고 가정

이 두 모델은 비행 방식이 같으므로, `XYZ`의 비행기는 다음과 같은 클래스 계통으로 설계할 수 있다.

```cpp
// 공항을 나타내는 클래스
class Airport { ... };  

class Airplane {
	public: 
		virtual void fly(const Airport& destination);
		...
};

void Airplane::fly(const Airport& destination)
{
	// A, B 모델 공통 비행 로직
  // 주어진 목적지로 비행기를 날려 보내는 기본 동작 원리를 가진 코드
}

class ModelA: public Airplane { ... }

class ModelB: public Airplane { ... }
```

`Airplane::fly` 함수는 모든 비행기가 `fly` 함수를 지원해야 한다는 점을 나타내야 하기 때문에 가상 함수로 선언되어 있다. 모델이 다른 비행기는 `fly` 함수에 대한 구현을 저마다 다르게 요구할 수 있다는 의미도 된다.

기본적인 비행 원리를 `Airplane::fly` 함수 본문으로 제공함으로써 이것을 `ModelA` 및 `ModelB`가 물려받을 수 있다.

두 클래스가 하나의 공통 특징(`fly` 함수를 구현하는 방법)을 공유하고 있으므로, 이 공통 특징을 기본 클래스로 올려보낸 뒤에 두 클래스가 이 특징을 물려받는 식으로 설계되었다.

### 이러한 고전적인 객체 지향 설계의 장점

- 클래스 사이의 공통 사항으로 둘 수 있는 특징이 명확해짐
- 코드가 중복되지 않음
- 이후의 기능 개선의 통로도 열려 있음
- 장기적인 유지 보수도 쉬움

이 상황에서 `ModelC`를 추가하는데 이 모델에 `fly` 함수를 재정의하는 것이 생략되었다고 가정하자.

```cpp
class ModelC: public Airplane {
	... // fly 함수가 선언되지 않음
};
```

이를 가지고 코드를 다음과 같이 만들 수 있다.

```cpp
// PDX는 임의의 가장 가까운 공항
Airport PDX(...);

Airplane *pa = new ModelC;
...
// [위험] ModelC가 A, B와 다른 비행 방식이 필요한데도 Airplane::fly의 기본 구현을 사용하게 됨
// Airplane::fly 함수가 호출된다.
pa->fly(PDX);
```

이는 `ModelC` 객체가 `ModelA`나 `ModelB`라도 된 것처럼 사용하는 코드가 되어버린다.

### ⚠️ 문제 사항

`Airplane::fly` 함수가 기본 동작을 구현해서 갖고 있다는 점이 아니라, `ModelC` 클래스는 이 기본 동작을 원한다고 명시적으로 밝히지 않았는데도 이 동작을 물려 받는데 문제가 없다는 것이다.

단, 기본 동작을 파생 클래스에게 제공하는 것도 쉽지만, 파생 클래스에서 요구하지 않으면 주지 않는 방법도 그리 어렵지 않다. 가상 함수의 인터페이스와 그 가상 함수의 기본 구현을 잇는 연결 관계를 끊는 것이다. 

## 해결 방법 1: 인터페이스와 기본 구현 분리

```cpp
class Airplane {
	public: 
		// 순수 가상함수로 변경
		virtual void fly(const Airport& destination) = 0;
		...
		
	protected:
		// 기본 구현을 별도 함수로 변경
		void defaultFly(const Airport& destination);
};

void Airplane::defaultFly(const Airport& destination)
{
  // 주어진 목적지로 비행기를 날려 보내는 기본 동작 원리를 가진 코드
}
```

`Airplane::fly` 함수가 순수 가상 함수로 바뀌었고, 이 가상 함수가 `fly` 함수의 인터페이스를 제공하는 역할을 맡게 된다. 

이전의 기본 구현은 `Airplane` 클래스에 `defaultFly`라는 이름의 별도 함수로 변경되었다. 기본 동작을 쓰고 싶은 `ModelA`와 `ModelB` 같은 클래스에서는 `fly` 함수의 본문 안에서 그냥 이 `defaultFly` 함수를 인라인 호출하기만 하면 된다. 

### **참고**: `Airplane::defaultFly` 함수는 `protected` 멤버

`Airplane::defaultFly` 함수는 `Airplane` 및 그 클래스의 파생 클래스만 내부적으로 사용하는 구현 세부사항이기 때문이다. 비행기를 사용하는 사용자는 “비행기를 날 수 있다”는 점만 알면 되고, “비행 동작이 어떻게 구현되는가”는 신경 쓰지 않아도 된다. 

이제 각 모델은 명시적으로 선택해야 한다.

```cpp
class ModelA: public Airplane {
	public:
		virtual void fly(const Airport& destination)
		{ defaultFly(destination); }
		...
};

class ModelB: public Airplane {
	public:
		virtual void fly(const Airport& destination)
		{ defaultFly(destination); }
		...
};

class ModelC: public Airplane {
	public:
		virtual void fly(const Airport& destination) {
        // [반드시 구현해야 함] ModelC만의 비행 로직 
    }
    ...
};
```

이제는 `ModelC` 클래스가 자신과 맞지 않는 기본 구현을 우연히 물려받을 가능성은 없어졌다. `fly` 함수가 `Airplain` 클래스의 순수 가상 함수로 선언되어 있어서, `ModelC` 만의 버전을 스스로 제공하지 않으면 안되기 때문이다.

```cpp
void ModelC::fly(const Airport& destination)
{
	// 주어진 목적지로 ModelC 비행기를 날려 보내는 코드
}
```

이 방법은 프로그래머의 실수를 완전히 막을 수 없지만, 원래의 설계보다는 낫다. 

## 해결 방법 2: 순수 가상함수에 구현 제공

```cpp
class Airplane {
	public: 
		virtual void fly(const Airport& destination) = 0;
		...
};

// 순수 가상 함수의 구현
void Airplane::fly(const Airport& destination)
{
  // 주어진 목적지로 비행기를 날려 보내는 기본 코드
}

class ModelA: public Airplane {
	public:
		virtual void fly(const Airport& destination)
		{ Airplain::fly(destination); }
		...
};

class ModelB: public Airplane {
	public:
		virtual void fly(const Airport& destination)
		{ Airplain::fly(destination); }
		...
};

class ModelC: public Airplane {
	public:
		virtual void fly(const Airport& destination)
		...
};

void ModelC::fly(const Airport& destination)
{
	// 주어진 목적지로 ModelC 비행기를 날려 보내는 코드
}
```

별도의 함수인  `Airplane::defaultFly`의 자리에 순수 가상 함수인 `Airplane::fly`의 본문이 들어와 있는 것만 제외하면 이전의 설계와 거의 같다. `fly` 함수가 선언부 및 정의부의 두 쪽으로 나뉘었다. 

선언부는 이 함수의 인터페이스(파생 클래스가 사용해야 하는 것)를 지정하고, 정의부는 이 함수의 기본 동작(파생 클래스가 사용해도 되나, 명시적으로 원할 경우에만 사용이 가능한)을 지정한다. 

하지만 `fly`와 `defaultFly`가 하나로 합쳐지는 바람에 함수 양쪽에 각기 다른 보호 수준을 부여할 수 있는 융통성은 날아가고 말았다. 그러므로 (`defaultFly`에 들어 있음으로써) `protected` 영역에 있었던 코드가 `fly` 안으로 옮겨졌으므로 이제는 `public` 영역에 있게 되었다. 

---

<aside>

# 📌 비가상 함수 (인터페이스 + 필수 구현 상속)

</aside>

## **`Shape`의 비가상 함수인 `objectID`**

```cpp
class Shape {
public:
	int objectID() const;
	...
};
```

## 목적

**파생 클래스가 인터페이스와 더불어 필수적인 구현(mandatory implementation)을 물려받게 하는 것**

### 비가상 함수의 의미:

- "이 함수는 파생 클래스에서 다른 행동이 일어나지 않는다"
- "클래스 파생에 상관없이 변하지 않는 동작을 수행한다"

### `Shape::objectID`의 의미:

- "모든 `Shape` 객체는 식별자를 가져야 한다"
- "식별자 계산 방법은 항상 동일하며, 바뀔 수 없다"

**중요:** 비가상 함수는 파생 클래스에서 재정의하면 안 된다.

---

<aside>

# 📌 흔한 설계 실수

</aside>

## 실수 1. 모든 멤버 함수를 비가상 함수로 선언

- 파생 클래스의 특수화 여지가 없어짐
- 특히 비가상 소멸자 문제 발생 가능
- 단, 파생을 염두에 두지 않은 클래스라면 적절함

### 참고: 80-20 법칙

보통의 프로그램에서는 전체 실행 시간의 80%가 소모되는 부분이 전체 코드의 20%밖에 되지 않는다는 법칙이다. 

정말 특수한 상황이 아니면 함수 호출 중 80%를 가상 함수로 두더라도 프로그램의 전체 수행 성능에는 가장 약하게 느낄 수 있을 만큼의 손실도 생기지 않는다는 뜻이기 때문이다. 가상 함수의 비용을 물까 말까 걱정하기 전에 비용의 유무에 따라 큰 차이를 만들 수 있는 20%의 코드에 집중하는 것이 좋을 수도 있다. 

## 실수 2: 모든 멤버 함수를 가상 함수로 선언

- 변하지 않아야 할 동작도 재정의 가능해짐
- 클래스의 불변 속성을 명확히 표현하지 못함

---

<aside>

# 📌 결론

</aside>

| 함수 유형 | 상속하는 것 | 의미 |
| --- | --- | --- |
| 순수 가상 함수 | 인터페이스만 | "반드시 구현" |
| 일반 가상 함수 | 인터페이스 + 기본 구현 | "기본 구현을 제공하지만, 필요시 재정의" |
| 비가상 함수 | 인터페이스 + 필수 구현 | "이 동작은 절대 바뀌면 안 된다" |

각각의 선언 방식은 서로 다른 의미를 가지므로, 클래스 설계 시 의도를 명확히 하여 적절한 방식을 선택해야 한다.

---