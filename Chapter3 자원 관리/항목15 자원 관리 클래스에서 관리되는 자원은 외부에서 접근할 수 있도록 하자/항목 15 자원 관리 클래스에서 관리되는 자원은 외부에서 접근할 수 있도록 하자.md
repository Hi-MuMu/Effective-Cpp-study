# 항목 15: 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자 - 작성자: 고형주

<aside>
🔎

# 이것만은 잊지말자!

- 실제 자원을 직접 접근해야 하는 기존 API들도 많기 때문에, RAII 클래스를 만들 때는 그 클래스가 관리하는 자원을 얻을 수 있는 방법을 열어 주어야 합니다.
- 자원 접근은 명시적 변환 혹은 암시적 변환을 통해 가능합니다. 안정성만 따지면 명시적 변환이 대체적으로 더 낫지만, 고객 편의성을 놓고 보면 암시적 변환이 괜찮습니다.
</aside>

## 핵심 용어

<aside>

### **RAII (Resource Acquisition Is Initialization)**

- **의미**: 자원 획득 즉 초기화
- **원칙**: 객체 생성 시 자원 획득, 객체 소멸 시 자원 해제
- **목적**: 자동 자원 관리, 예외 안전성 보장

### **std::tr1::shared_ptr<T>**

- **의미**: 여러 객체가 같은 자원을 공유할 수 있는 스마트 포인터
- **작동**: 참조 카운팅 방식으로 자원 자동 관리
- **tr1**: Technical Report 1 (C++11 이전 확장 라이브러리)

### **std::auto_ptr<T>**

- **의미**: 하나의 소유자만 가질 수 있는 스마트 포인터
- **특징**: 복사 시 소유권 이전 (독점적 소유권)
- **상태**: C++11에서 deprecated
</aside>

<aside>

## 변환 관련 용어

### **명시적 변환 (Explicit Conversion)**

- **의미**: 프로그래머가 의도적으로 명시하는 타입 변환
- **예시**: `.get()` 함수 호출, 생성자 직접 호출
- **특징**: 코드에서 변환 의도가 명확히 보임

### **암시적 변환 (Implicit Conversion)**

- **의미**: 컴파일러가 자동으로 수행하는 타입 변환
- **예시**: `operator->`, `operator*`, 사용자 정의 변환 연산자
- **위험성**: 의도하지 않은 변환 가능

### **operator-> / operator**

- **역할**: 포인터처럼 사용할 수 있게 해주는 연산자 오버로딩
- **특징**: 스마트 포인터에서 자주 구현됨
- **효과**: 일반 포인터처럼 자연스러운 사용 가능
</aside>

<aside>

## C API 관련 용어

### **C API (C Application Programming Interface)**

- **의미**: C 언어로 작성된 라이브러리 인터페이스
- **구성**: 원시 포인터, 함수들로 이루어짐
- **특징**: 수동 자원 관리 필요

### **Handle (핸들)**

- **의미**: 자원을 간접적으로 참조하는 식별자
- **예시**: `FontHandle`, `FileHandle`, `HWND` 등
- **역할**: 실제 자원에 대한 추상화된 접근 방법

### **Factory Function (팩토리 함수)**

- **의미**: 객체 생성을 담당하는 함수
- **특징**: 기본 클래스 포인터 반환, 실제로는 파생 클래스 객체 생성
- **목적**: 생성 과정 캡슐화, 다형성 구현
</aside>

---

<aside>

# 📌 RAII 클래스의 객체를 실제 자원으로 변환할 방법의 필요성

</aside>

## 문제 상황

```cpp
std::tr1::shared_ptr<Investment> pInv(createInvestment());

int daysHeld(const Investment *pi);  // 투자금이 유입된 이후로 경과한 날 수

int days = daysHeld(pInv);   // 에러 발생
```

위와 같이, 팩토리 함수를 호출한 결과(포인터)를 담기 위해 `auto_ptr` 혹은 `tr1::shared_ptr`와 같은 스마트 포인터를 사용할 수 있다. **하지만 이 코드는 컴파일 되지 않는다.**

## 왜 에러가 발생할까?

- `daysHeld` 함수는 `Investment*` 타입의 실제 포인터를 원한다.
- `pInv`는 `tr1::shared_ptr<Investment>` 타입의 객체를 넘기고 있다.
- 두 타입이 다르므로 변환 방법이 필요

그러므로 **`RAII 클래스`(여기서는 `tr1::shared_ptr`)의 객체를 실제 자원으로 변환할 방법이 필요**하다.

## 해결 방법

1. 명시적 변환
2. 암시적 변환

---

<aside>

# 📌 명시적 변환

</aside>

## get을 사용한 명시적 변환

`tr1::shared_ptr` 및 `auto_ptr` 는 **명시적 변환을 수행하는 `get` 이라는 멤버 함수를 제공**한다.

즉, get을 사용하면 각 타입으로 만든 스마트 포인터 객체에 들어있는 실제 포인터(의 사본)을 얻어낼 수 있다.

```cpp
// tr1::shared_ptr와 auto_ptr이 제공하는 get 함수
int days = daysHeld(pInv.get());  // pInv에 들어 있는 실제 포인터 반환
```

위의 코드처럼, 명시적 변환으로 `RAII 클래스`의 객체를 실제 자원으로 변환이 가능하다.

---

<aside>

# 📌 포인터에 대한 암시적 변환(포인터 역참조 연산자를 통한 접근)

</aside>

스마트 포인터 클래스인 `tr1::shared_ptr` 와  `auto_ptr` 는 포인터 역참조 연산자(`operator →` 및 `operator*`)도 오버로딩하고 있다.

그러므로 **실제 포인터에 대한 암시적 변환도 할 수 있다.** 

```cpp
// 여러 형태의 투자를 모델링한 투자 클래스들의 최상위 클래스
class Investment {
  public: 
	  bool isTaxFree() const;
	  ...
};

// 팩토리 함수
Investment* createInvestment();

// tr1::shared_ptr이 자원 관리를 맡도록 함
std::tr1::shared_ptr<Investment> pi1(createInvestment());

// operator->를 사용해서 자원에 접근
bool taxable1 = !(pi1->isTaxFree());  // <--- 포인터 역참조 연산자

...

// auto_ptr로 하여금 자원 관리를 맡도록 함
std::auto_ptr<Investment> pi2(createInvestment());

// operator*를 사용해서서 자원에 접근
bool taxable2 = !((*pi2).isTaxFree());  // <--- 포인터 역참조 연산자
```

위의 코드처럼, 포인터에 대한 암시적 변환으로 `RAII 클래스`의 객체를 실제 자원으로 변환이 가능하다. 

`pi1->isTaxFree()`가 `(pi1.operator->())->isTaxFree()`로 변환되므로, 사용자는 실제 포인터를 쓰는 것처럼 자연스럽게 사용 가능하다. 

---

<aside>

# 📌 암시적 변환 함수

</aside>

## 암시적 변환 함수의 필요성

* RAII 객체 안에 들어있는 실제 자원을 얻어낼 필요가 생기기 때문에, **RAII 클래스 설계자 중에는 암시적 변환 함수를 제공하여 자원 접근을 원활하게 하는 경우도 있다.** 

## `Font` 클래스 예시

어떤 하부 수준 C API로 직접 조작이 가능한 폰트를 RAII 클래스로 둘러싸서 쓰는 경우를 예시로 든다.

```cpp
// C API에서 가져온 함수: 매개변수가 있으면 복잡하기 때문에 생략
FontHandle getFont();

// C API에서 가져온 함수
void releaseFont(FontHandle fh); 

class Font {
	public:
		// 자원 획득
		// 값에 의한 전달이 수행됨
		// 자원 해제를 C API로 하기 때문이다
		explicit Font(FontHandle fh)
		: f(fh)
		{}
		
		~Font() { releaseFont(f); }
		
	private:
		// 실제 폰트 자원
		FontHandle f;
};
```

하부 수준 C API는 `FontHandle`을 사용하도록 만들어져 있으며 규모도 크다고 가정한다. 이 때, Font 객체를 `FontHandle`로 변환해야 할 경우도 생길 수 있다. 이를 위해서 `Font` 클래스에서는 명시적 변환 함수로 `get`을 제공할 수 있다. 

## 명시적 변환 함수로 `get`을 제공

```cpp
// C API에서 가져온 함수: 매개변수가 있으면 복잡하기 때문에 생략
FontHandle getFont();

// C API에서 가져온 함수
void releaseFont(FontHandle fh); 

class Font {
	public:
		// 자원 획득
		// 값에 의한 전달이 수행됨
		// 자원 해제를 C API로 하기 때문이다
		explicit Font(FontHandle fh)
		: f(fh)
		{}
		
		// 명시적 변환 함수 (Font 객체를 FontHandle로 변환해야 할 경우 사용)
		FontHandle get() const { return f; }  // <---------- get 제공
		
		~Font() { releaseFont(f); }
		
	private:
		// 실제 폰트 자원
		FontHandle f;
};
```

하지만 이렇게 쓰게 되면, 다음과 같이 하부 수준 API를 쓰고 싶을 때마다 `get`을 호출해야 한다는 문제가 있다.

```cpp
// 폰트 API의 일부
void changeFontSize(FontHandle f, int newSize);

Font f(getFont());
int newFontSize;

...

// Font에서 FontHandle로 명시적으로 바꾼 후에 넘깁니다.
changeFontSize(f.get(), newFontSize);
```

이렇게 변환할 때마다 특정 함수를 호출해야 한다. 함수 호출이 번거로워서 `Font`를 안 쓰게 된다면 폰트의 자원이 누출될 수도 있다. `Font`를 설계한 가장 큰 목적이 폰트 자원 누출을 막는 것이기 때문이다.

## 대안: `FontHandle`로의 암시적 변환 함수를 `Font`에서 제공

```cpp
class Font {
	public:
		...
		// 암시적 변환 함수
		operator FontHandle() const
		{ return f; }
		...
};
```

암시적 변환 덕분에 아래와 같이 C API를 사용하기가 쉬워진다.

```cpp
Font f(getFont());
int newFontSize();

...

// Font에서 FontHandle로 암시적 변환을 수행
changeFontSize(f, newFontSize);
```

## 암시적 변환의 위험성

그러나 암시적 변환이 들어가면 실수할 여지가 증가한다. 다음과 같이 진짜 `Font`를 쓰려고 한 부분에서 원하지 않게 `FontHandle`로 바뀔 수 있기 때문이다.

```cpp
Font f1(getFont());

...

// 의도: Font 객체 복사
// 실제: f1이 FontHandle로 변환된 후 복사
FontHandle f2 = f1;  // [위험] 같은 자원을 두 곳에서 관리

// 문제 상황:
// 1. f1 소멸 → releaseFont(handle) 호출
// 2. f2는 여전히 해제된 handle을 가지고 있음
// 3. f2를 사용하려 하면 → 미정의 동작 (크래시 가능)
```

이렇게 되면 Font 객체인 `f1`이 관리하고 있는 폰트(`FontHandler`)가 `f2`를 통해서도 직접 사용할 수 있는 상태가 된다. 하나의 자원이 양 쪽에 걸치고 있는 상황은 좋지 않다. `f1`이 소멸될 시점에서 폰트가 해제될 텐데, `f2`는 해제된 폰트에 남아있기 때문이다.

## 포인터 역참조 연산자와 암시적 변환 함수의 차이점

- `operator->`, `operator*`: 포인터처럼 **사용**하기 위한 연산자
- `operator FontHandle()`: 실제 자원 타입으로 **변환**하기 위한 함수

---

<aside>

# 📌 선택은 RAII 클래스만의 특정한 용도와 사용 환경에 따라 달라진다.

</aside>

## 🔄 사용법 비교

RAII 클래스를 실제 자원으로 바꾸는 방법으로 명시적 변환을 제공할 것인지(get 멤버 함수 등) 아니면 암시적 변환을 허용할 것인지에 대한 결정은 그 RAII 클래스만의 특정한 용도에 따라 달라진다. 

```cpp
Font font(getFont());

// 명시적 변환 사용
changeFontSize(font.get(), newSize);  // 안전하지만 번거로움

// 암시적 변환 사용  
changeFontSize(font, newSize);        // 편리하지만 실수 위험
```

**암시적 변환보다는 get 등의 명시적 변환 함수를 제공하는 쪽이 나을 때가 많다.** 원치 않은 타입 변환이 일어날 여지를 줄여주기 때문이다. 하지만 암시적 타입 변환에서 생기는 자연스러운 사용이 나을 때도 있다. 

## 🎯 선택 기준

- **안전성 우선**: 명시적 변환 (get 함수)
- **편의성 우선**: 암시적 변환 (operator 오버로딩)

---

<aside>

# 📌 RAII 클래스에서 자원 접근을 제공하는 설계는 캡슐화에 위배지만, 문제는 되지 않는다.

</aside>

## 캡슐화에 위배되지만 문제는 없다.

RAII 클래스에서 자원 접근 함수를 열어주는 설계는 캡슐화에 위배되지만, 좋지 않은 설계인 것도 아니다. RAII 클래스는 데이터 은닉을 목적으로 하는 클래스가 아니기 때문에, 원하는 동작(자원 해제)이 실수 없이 실행되면 되면 된다. 또한 ‘자원 해제’라는 기본 기능 위에 캡슐화 기능을 추가할 수는 있지만 필수는 아니다. 

## 참고

시중에 있는 RAII 클래스 중에는 이미 자원의 엄격한 캡슐화와 느슨한 캡슐화를 지원하는 것들이 있다. 

예를 들어 `tr1::shared_ptr`가 있다. 이 클래스는 참조 카운팅 메커니즘에 필요한 장치들은 모두 캡슐화하고 있지만, 그와 동시에 자신이 관리하는 포인터를 쉽게 접근할 수 있는 통로도 제공한다. 사용자가 볼 필요가 없는 데이터는 가리지만, 고객 차원에서 꼭 접근해야 하는 데이터는 열어주는 것이다. 

```cpp
// tr1::shared_ptr의 균형잡힌 설계 예시
std::tr1::shared_ptr<int> ptr(new int(42));

// 숨겨진 것: 참조 카운팅 메커니즘
// - 복사될 때마다 카운트 증가
// - 소멸될 때마다 카운트 감소
// - 카운트가 0이 되면 자원 해제

// 열어준 것: 실제 포인터 접근
int* raw = ptr.get();        // 명시적 접근
int value = *ptr;           // operator* 통한 접근
```

## ✅ 결론

<aside>

RAII 클래스에서 자원 접근을 제공하는 것은 캡슐화 위반이 아니다. RAII의 목적은 **자원 해제 보장**이지 데이터 은닉이 아니기 때문이다.

</aside>