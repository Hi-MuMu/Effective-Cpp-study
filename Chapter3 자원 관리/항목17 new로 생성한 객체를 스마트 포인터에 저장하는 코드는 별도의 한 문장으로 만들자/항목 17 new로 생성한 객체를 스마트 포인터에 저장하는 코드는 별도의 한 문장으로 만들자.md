# 항목 17: new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자 - 작성자: 고형주

<aside>
🔎

# 이것만은 잊지말자!

- new로 생성한 객체를 스마트 포인터로 넣는 코드는 별도의 한 문장으로 만듭시다. 이것이 안 되어 있으면, 예외가 발생될 때 디버깅하기 힘든 자원 누출이 초래될 수 있습니다.
</aside>

## 핵심 용어

<aside>

## 컴파일러 동작 관련 용어

### **매개변수 평가 순서 (Parameter Evaluation Order)**

- **C++ 특징**: 함수 인자들이 계산되는 순서가 정해져 있지 않음
- **컴파일러 자유도**: 효율성을 위해 순서 조정 가능
- **다른 언어 비교**: Java, C# 등은 평가 순서 고정

### **문장 경계 (Statement Boundary)**

- **정의**: 세미콜론(;)으로 구분되는 문장들 사이의 경계
- **보장**: 컴파일러는 문장 순서를 바꿀 수 없음
- **활용**: 실행 순서 보장이 필요할 때 별도 문장으로 분리

### **원자적 실행 (Atomic Execution)**

- **의미**: 중간에 끼어들 수 없는 하나의 완전한 실행 단위
- **적용**: `new`와 스마트 포인터 생성을 한 문장에서 처리
- **효과**: 예외가 발생해도 자원 누수 방지
</aside>

<aside>

## 예외 안전성 용어

### **예외 안전성 (Exception Safety)**

- **의미**: 예외가 발생해도 자원 누수나 불일치 상태가 발생하지 않는 특성
- **중요성**: 견고한 프로그램을 위한 필수 요소
- **구현**: RAII 패턴과 올바른 문장 분리로 달성

### **자원 누수 (Resource Leak)**

- **발생 상황**: 할당된 자원이 해제되지 않고 남아있는 상태
- **원인**: 예외 발생으로 정리 코드가 실행되지 않을 때
- **방지**: 스마트 포인터와 RAII 패턴 활용
</aside>

<aside>

## 컴파일 관련 용어

### **explicit 생성자**

- **의미**: 암시적 타입 변환을 막는 키워드
- **목적**: 의도하지 않은 변환 방지
- **예시**: `tr1::shared_ptr` 생성자가 `explicit`로 선언됨

### **컴파일 에러 vs 런타임 에러**

- **컴파일 에러**: `new Widget`을 `shared_ptr`로 직접 전달
- **런타임 에러**: 예외 발생으로 인한 메모리 누수
- **해결**: 명시적 변환과 문장 분리
</aside>

---

<aside>

# 📌 자원 관리 객체를 쓰더라도 누수가 생길 수 있다.

</aside>

## 스마트 포인터 변환 문제

처리 우선순위를 알려주는 함수가 있고, 동적으로 할당한 `Widget` 객체에 대해 어떤 우선순위에 따라 처리를 적용하는 함수가 있다고 가정하자.

```cpp
// 처리 우선순위를 알려주는 함수
int priority();

// 동적으로 할당한 Widget 객체에 대해 어떤 우선순위에 따라 처리를 적용하는 함수
// (스마트 포인터 사용)
void processWidget(std::tr1::shared_ptr<Widget> pw, int priority);
```

자원 관리에는 객체를 사용하는 것이 좋기 때문에, `process Widget` 함수는 동적 할당된 `Widget` 객체에 대해 스마트 포인터(`tr1::shared_ptr`)를 사용하도록 만들어졌다.

이렇게 만들어진 `processWidget` 함수를 호출하면  컴파일이 되지 않는다

```cpp
processWidget(new Widget, priority());
```

## 에러 발생 이유

- `tr1::shared_ptr` 생성자가 `explicit`로 선언되어 있음
- `new Widget`에서 `tr1::shared_ptr<Widget>`로 암시적 변환 불가

포인터를 받는 `tr1::shared_ptr`의 생성자는 `explicit`로 선언되어 있기 때문에, ‘`new Widget`’ 표현식에 만들어진 포인터가 `tr1::shared_ptr` 타입의 객체로 바꾸는 명시적인 변환이 없어서 그렇다. `processWidget`에는 `tr1::shared_ptr`가 필요하기 때문이다. 

## 일차적인 해결 방법

다음과 같이 `tr1::shared_ptr` 타입의 객체로 바꾸는 명시적 변환을 하면 컴파일이 된다. 

```cpp
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());
```

하지만 이 코드에서 **자원 관리 객체를 쓰고 있는데도 자원 누수의 가능성은 있다.** 

## ⚠️ 문제 상황 - 예외 발생 시 메모리 누수

```cpp
// 현재 코드
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());

// 실행 순서가 이렇게 될 수 있음:
// 1. new Widget 실행
// 2. priority() 호출 ← 여기서 예외가 발생 가능
// 3. shared_ptr 생성자 호출 (실행되지 않음)
// → Widget 객체 누수
```

---

<aside>

# 📌 컴파일러마다 연산이 실행되는 순서는 다를 수 있다.

</aside>

## 컴파일러 평가 순서 진행

컴파일러는 `processWidget`  호출 코드를 만들기 전에, 이 함수의 매개변수로 넘겨지는 인자를 평가(evaluate)하는 순서를 진행한다. 여기서 두 번째 인자는 `priority` 함수의 호출문밖에 없지만, 첫번째 인자(”`std::tr1::shared_ptr<Widget>(new Widget)`”)는 두  부분으로 나뉘어 있다. 

- “`new Widget`” 표현식을 실행하는 부분
- `tr1::shared_ptr` 생성자를 호출하는 부분

이렇게 두 부분으로 나뉘기 때문에, `processWidget` 함수 호출이 이루어지기 전에 컴파일러는 다음의 세 가지 연산을 위한 코드를 만들어야 한다. 

- `priority` 호출
- “`new Widget`”을 실행
- `tr1::shared_ptr` 생성자를 호출

## 실행 순서의 불확실성

연산이 실행되는 순서는 효율성을 위해 조정이 가능하므로, 컴파일러 제작사마다 순서가 다르다. Java나 C#과 달리 C++은 매개변수 평가 순서가 정해져 있지 않으므로, **C++ 컴파일러는 평가 순서를 정하는데 자유도가 있기 때문이다.**

예를 들어, “`new Widget`” 표현식은 `tr1::shared_ptr` 생성자가 실행될 수 있기 전에 호출되어야 한다. 이 표현식의 결과가 `tr1::shared_ptr`  생성자의 인자로 넘어가기 때문이다. 그러나 `priority` 호출은 처음 호출될 수도 있고, 두 번째나 세 번째에 호출될 수도 있다. 만약 어떤 컴파일러에서 두 번째라고 정했다면 연산 순서는 다음과 같이 결정된다. 

1. `new Widget` 실행 → Widget 객체 생성
2. `priority()` 호출 → 우선순위 계산
3. `tr1::shared_ptr` 생성자 호출 → 스마트 포인터 생성

```cpp
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());

// 컴파일러가 선택할 수 있는 실행 순서:
// 1️⃣ new Widget 실행        ← Widget 객체 생성됨
// 2️⃣ priority() 호출        ← [예외 발생]
// 3️⃣ shared_ptr 생성자 호출  ← 실행되지 않음!
```

하지만 “`priority` 호출" 부분에서 예외가 발생하면 “`new Widget`”로 만들어졌던 포인터가 유실될 수 있다. 자원 누출을 막아줄 줄 알고 준비한 `tr1::shared_ptr` 에 저장되기도 전에 예외가 발생하기 때문이다. 결국 processWidget 호출 중에 자원이 누출된 가능성이 있는 이유는, 자원이 생성되는 시점(“`new Widget`”을 통한)과 그 자원이 자원 관리 객체로 넘어가는 시점 사이에 예외가 끼어들 수 있기 때문이다. 

## **결과**

Widget 객체는 힙에 남아있지만 누구도 관리하지 않음 ⇒ **메모리 누수**

---

<aside>

# 📌 객체를 스마트 포인터에 저장하라

</aside>

## ✅ 문제 해결

이런 문제는 다음과 같이 해결할 수 있다. `Widget` 을 생성해서 스마트 포인터에 저장하는 코드를 별도의 문장 하나로 만들고, 그 스마트 포인터를 `processWidget` 에 넘기는 방법이다. 

```cpp
// 1단계: 별도 문장으로 스마트 포인터 생성
// new로 생성한 객체를 스마트 포인터에 담는 코드를 하나의 독립적인 문장으로 만든다.
std::tr1::shared_ptr<Widget> pw(new Widget);

// 2단계: 안전하게 함수 호출
// 이제는 자원 누출이 되지 않는다.
processWidget(pw, priority());
```

### 왜 안전한가?

- **문장 경계:** 컴파일러는 문장과 문장 사이의 순서는 바꿀 수 없음
- **원자적 실행:** `new Widget`과 `shared_ptr` 생성이 한 문장에서 완료
- **예외 안전성:** `priority()`에서 예외가 나도 `pw`가 이미 자원을 관리 중

한 문장 안에 있는 연산들보다 문장과 문장 사이에 있는 연산들이 컴파일러의 재조정을 받을 여지가 적기 때문에, 위 코드는 자원 누출 가능성이 없다. 

고쳐진 코드를 보면 “`new Widget`” 표현식과 `tr1::shared_ptr` 생성자는 한 문장에 들어있고, `priority` 를 호출하는 코드는 별도의 문장에 있다. 그러므로 컴파일러가 `priority` 호출을 둘 사이로 옮길 수가 없다.

## 비교 정리

| 방식 | 안전성 | 이유 |
| --- | --- | --- |
| `processWidget(shared_ptr<Widget>(new Widget), priority())` | ❌ 위험 | 실행 순서 불확실 |
| `shared_ptr<Widget> pw(new Widget); processWidget(pw, priority())` | ✅ 안전 | 문장 경계로 순서 보장 |

## 🎯 결론

<aside>

자원 생성과 관리 객체 할당을 원자적으로(한 문장에서) 수행하여 예외 안전성을 보장해야 한다.

- 복잡한 함수 호출에서는 인자 준비를 별도 문장으로 분리
- *new와 스마트 포인터는 항상 같은 문장에서 처리*
- *예외가 발생할 수 있는 함수 호출과 분리*
</aside>