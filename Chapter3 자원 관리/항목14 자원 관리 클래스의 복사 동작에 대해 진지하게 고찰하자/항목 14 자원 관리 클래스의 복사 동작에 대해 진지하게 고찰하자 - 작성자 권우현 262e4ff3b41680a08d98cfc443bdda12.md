# 항목 14: 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자 - 작성자: 권우현

<aside>

# 💡이것만은 잊지말자!

- RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에, 그 자원을 어떻게 복사하느냐에 따라 RAII 객체의 복사 동작이 결정됩니다.
- RAII 클래스에 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해주는 선으로 마무리하는 것입니다. 하지만 이 외의 방법들도 가능하니 참고해 둡시다.
</aside>

---

# 📘 RAII 객체 복사와 자원 관리 전략

---

## 1. 상황 설명: 힙 외 자원의 RAII 관리 필요

- 모든 자원이 힙에서만 생기는 것이 아님
- 사용자가 직접 **자원 관리 클래스**를 만들어야 할 경우 존재
- 예: **C API의 Mutex 객체**를 사용하는 상황

---

- Mutex 란?
    - *Mutex(Mutual Exclusion Object)**는 **상호 배제 객체**라고 불리며, 여러 스레드가 **공유 자원에 동시에 접근하지 못하도록 하는 동기화 도구**입니다.
        - 동시에 접근하면 무슨일이 벌어지지?
            
            ### 문제: 동시에 접근하면 데이터가 꼬일 수 있음
            
            여러 스레드가 같은 자원(예: 변수, 배열, 파일)에 동시에 읽고 쓰기를 하면 **데이터 경쟁(Race Condition)**이 발생할 수 있어요.
            
            예를 들어, 변수 `counter = 0`이 있을 때:
            
            ```cpp
            // Thread A
            counter = counter + 1;
            
            // Thread B
            counter = counter + 1;
            
            ```
            
            - Thread A와 B가 동시에 실행되면, CPU는 다음과 같이 동작할 수 있어요:
                1. Thread A가 `counter` 값을 읽음 → 0
                2. Thread B가 `counter` 값을 읽음 → 0
                3. Thread A가 1을 더하고 저장 → counter = 1
                4. Thread B가 1을 더하고 저장 → counter = 1
            - 결과: 실제로 2번 더했는데 **counter 값이 1**이 돼버려요. 😱
            
            이처럼 **동시 접근 때문에 계산 결과가 예상과 다르게 되는 것**이 문제입니다.
            
    - 여러 스레드가 동시에 데이터를 읽고 쓰는 상황에서 **데이터 경쟁(Race Condition)**을 방지하기 위해 사용합니다.
    - 한 번에 **한 스레드만 자원을 사용할 수 있도록 잠금(lock)과 해제(unlock)**을 제공합니다.

---

```cpp
void lock(Mutex *pm);      // pm이 가리키는 뮤텍스 잠금
void unlock(Mutex *pm);    // pm이 가리키는 뮤텍스 잠금 해제

```

- 목적: **뮤텍스 잠금/해제를 자동으로 관리**
- RAII 법칙 준수:
    - 생성 시 자원 획득
    - 소멸 시 자원 해제

```cpp
class Lock {
public:
    explicit Lock(Mutex *pm)
        : mutexPtr(pm)      // 멤버 변수 초기화
    {
        lock(mutexPtr);    // 자원 획득
    }

    ~Lock() {
        unlock(mutexPtr);  // 자원 해제
    }

private:
    Mutex *mutexPtr;        // 잠글 뮤텍스 포인터
};

```

```cpp
Mutex m;
{
    Lock ml(&m);  // 블록 시작 시 뮤텍스 잠금
    ...
} // 블록 끝 → 뮤텍스 자동 해제

```

---

## 2. Lock 객체가 복사된다면 어떻게 해야 할까?: RAII 객체 복사

```cpp
Lock m11(&m); // m에 잠금을 겁니다
Lock m12(m11); // m11 을 m12로 복사합니다. 어떻게 되어야 맞을까?
```

- **RAII 클래스를 생성시:  RAII 객체 복사 의 경우에 어떠한 동작이 이루어져야 하는지 ?**

### **1) 복사 금지**

- 대부분의 RAII 객체는 복사 의미가 없음
- 예: Lock 클래스 → 스레드 동기화 객체 사본은 무의미
- 구현:

```cpp
class Lock: private Uncopyable { // 복사 금지
public:
    ...
};

```

### 2) 관리하고 있는 자원에 대해 참조 카운팅을 수행

- 여러 객체가 동일 자원을 공유
- 마지막 객체 소멸 시 자원 해제
- 예: `tr1::shared_ptr` 사용
- 주의: Mutex 잠금 해제만 원할 경우, 기본 deleter 대신 커스텀 삭제자 지정

```cpp
class Lock {
public:
    explicit Lock(Mutex *pm)
        : mutexPtr(pm, unlock) // 삭제자 unlock 지정
    {
        lock(mutexPtr.get());
    }

private:
    std::tr1::shared_ptr<Mutex> mutexPtr; // raw pointer 대신 shared_ptr
};

```

- 소멸자 불필요 → shared_ptr이 자동 처리

### 3) **깊은 복사 (Deep Copy) : 관리하고 있는 자원을 진짜로 복사하기**

- 자원 자체를 복사하여 새로운 RAII 객체 생성
- 예: 문자열 클래스 구현에서 힙 메모리를 갖는 경우

### 4) 관리하고 있는 자원의 소유권을 옮기기

- RAII 객체 복사 시 원본 → 사본으로 자원 소유권 이동
- 예: auto_ptr의 복사 동작
- 흔한 경우 아님

---

## 3. 결론: RAII 객체 복사 전략

- **RAII 객체 복사 함수**(복사 생성자/복사 대입 연산자)는 컴파일러가 자동 생성 가능
- 하지만 **자동 생성 동작이 의도와 다를 수 있음**
- 따라서 **직접 복사 함수를 정의**하여 자원 관리 정책에 맞게 제어 필요