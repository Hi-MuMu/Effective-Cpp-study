# 항목 13: 자원 관리에는 객체가 그만! - 작성자: 권우현

<aside>

# 💡이것만은 잊지말자!

- 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII (자원 획득 즉 초기화) 객체를 사용합시다.
- 일반적으로 널리 쓰는 RAII 클래스는 tr1 : : shared_ptr 그리고 auto_ptr 입니다. 이 둘 가운데 tr1 : : shared_ptr 이 복사 시의 동작이 직관적이기 때문에 대개 더 좋습니다. 반면, auto_ptr 은 복사되는 객체(원본 객체)를 null로 만들어 버립니다.
</aside>

---

# 📘 스마트 포인터 & RAII: 투자 객체 수명 관리

---

## 1. 상황 설명: Investment 팩토리와 수명 관리 문제

투자 (주식이나 채권 등)를 모델링 해주는 클래스 라이브러리를 가지고 어떤 작업을 한다고 가정.

라이브러리에는 `Investment`라는 최상위 클래스가 있음.

```jsx
class Investment {...}; // 여러 형태의 투자를 모델링한
												// 클래스 계통의 최상의 클래스

Investment * createInvestment(); // Investment 클래스 계통에 속한 클래스의 객체를 동적
																 // 할당하고 그 포인터를 반환합니다.
																 // 이 객체의 해제는 호출자 쪽에서 직접 해야 합니다.

```

호출자(caller)는 `createInvestment`로 얻은 객체를 사용 후 필요 없으면 삭제해야 함.

```jsx
호출자 f()

void f()
{
	Investment *pInv = createInvestment(); // 팩토리 함수를 호출합니다.
	...
	delete pInv; // 객체를 해제합니다.
}

```

### 문제점

- … 부분에서의 `return` 문 ⇒ `delete`까지 도달하지 못함
- `continue`나 `goto`로 루프를 빠져나가면 `delete` 미실행
- 코드 안의 예외 발생 시 `delete` 미실행
- 유지보수 과정에서 다른 사람이 `delete`를 놓칠 가능성이 높음

<aside>
💡

해결아이디어!

createInvestment 함수로 얻은 자원을 **객체에 넣고, 소멸자가 자원을 해제하도록 맡기면**,

`f`를 떠나는 경로와 상관없이 자원 해제가 보장됨.

</aside>

---

## 2. 관련 개념: RAII와 스마트 포인터

### 2-1. RAII (Resource Acquisition Is Initialization)

- 자원 획득과 자원 관리 객체 초기화를 **한 문장**에서 수행
- 객체의 소멸자를 통해 자원을 안전하게 반환

---

### 2-2. auto_ptr (스마트 포인터, C++98~C++03)

```cpp
void f ()
{
 std: :auto_ptr<Investment> plnv(createlnvestment ()) ; // 팩토리 함수를 호출
																											  // plnv 사용 가능
}																												// plnv 소멸 → 자동 delete

```

- 첫째: 자원 획득 후 **자원 관리 객체**에게 전달
- 둘째: 자원 관리 객체의 소멸자를 통해 자원 자동 해제
- 주의: **delete를 두 번 호출하는 문제 발생 가능**
    - 그래서 그것을 해결하기 위해 auto_ptr은 기본적으로 복사하면 원본 객체는 null이 됨

---

## 3. 예시 코드와 동작

```cpp
int* p = new int(42);

delete p;   // 정상
delete p;   // double free → 문제 발생

```

### 발생 문제

- 이미 해제된 메모리를 다시 해제 → **double free** 에러
- 어떤 시스템에서는 바로 프로그램이 죽음 (Segmentation fault)
- 어떤 환경에서는 **정의되지 않은 동작** (Undefined Behavior)
    - 메모리 오염
    - 다른 코드 실행 중 이상 동작
    - 디버깅도 어려움

<aside>
💡

`auto_ptr`은 소멸자에서 `delete`를 호출함.

만약 같은 객체를 두 `auto_ptr`이 동시에 가리키면:

- 객체가 소멸될 때 두 `auto_ptr`이 각각 `delete` 호출
- 결과적으로 **delete가 두 번 실행**됨 → 프로그램이 터짐

👉 그래서 auto_ptr은 **소유권을 한쪽으로 강제로 넘기는 특이한 동작**을 하게됨.

</aside>

---

## 4. 해결책: 참조 카운팅 스마트 포인터 (shared_ptr)

```cpp
void f()
{
    std::tr1::shared_ptr<Investment> pInv1(createInvestment());
		// pInv1이 가리키는 대상은
    // createInvestment 함수에서 반환된 객체입니다.
    
    std::tr1::shared_ptr<Investment> pInv2(pInv1);
    // pInv1 및 pInv2가 동시에 그 객체를 가리키고 있습니다.

    pInv1 = pInv2;
    // 반환은 없음
}
// pInv1 및 pInv2는 소멸되며,
// 이들이 가리키고 있는 객체도 자동으로 삭제됩니다.

```

- auto_ptr 대신 `shared_ptr` 사용 가능
- 참조 카운트 0 → 객체 자동 삭제

### 주의점

- 동적 배열에는 `auto_ptr`/`shared_ptr` 사용 시 잘못된 delete 사용 가능
    
    → delete 대신 delete[] 필요
    

---

## 5. 정리

1. `new`로 할당한 객체는 **한 번의 delete**로 해제
2. delete 누락 → **메모리 누수**
3. delete 두 번 → **double free / Undefined Behavior**
4. RAII + 스마트 포인터 사용으로 자원 안전 확보
5. auto_ptr 문제 → `unique_ptr` / `shared_ptr` 사용